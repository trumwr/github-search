/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCellSelection = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _useProperty3 = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/useProperty"));
var _batchUpdate = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/batchUpdate"));
var _clamp = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/clamp"));
var _useActiveCell2 = _interopRequireDefault(require("./useActiveCell"));
var _usePrevious = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/usePrevious"));
var _useNamedState3 = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/useNamedState"));
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var getFirstSelectedCell = function getFirstSelectedCell(cellSelection) {
  return cellSelection.sort(function (cell1, cell2) {
    if (cell1[0] < cell2[0]) {
      return -1;
    } else if (cell1[0] > cell2[0]) {
      return 1;
    }
    return cell1[1] < cell2[1] ? -1 : 1;
  })[0];
};
var useCellSelection = function useCellSelection(props, _ref, computedPropsRef) {
  var rowSelectionEnabled = _ref.rowSelectionEnabled,
    hasRowNavigation = _ref.hasRowNavigation,
    listenOnCellEnter = _ref.listenOnCellEnter;
  var _useProperty = (0, _useProperty3.default)(props, 'cellSelection'),
    _useProperty2 = (0, _slicedToArray2.default)(_useProperty, 2),
    cellSelection = _useProperty2[0],
    setCellSelection = _useProperty2[1];
  var _useNamedState = (0, _useNamedState3.default)(false, props.context, 'bulkUpdateMouseDown'),
    _useNamedState2 = (0, _slicedToArray2.default)(_useNamedState, 2),
    bulkUpdateMouseDown = _useNamedState2[0],
    setBulkUpdateMouseDown = _useNamedState2[1];
  var _useActiveCell = (0, _useActiveCell2.default)(props, computedPropsRef),
    computedActiveCell = _useActiveCell.computedActiveCell,
    getCellSelectionIdKey = _useActiveCell.getCellSelectionIdKey,
    getCellSelectionBetween = _useActiveCell.getCellSelectionBetween,
    setActiveCell = _useActiveCell.setActiveCell,
    getCellSelectionKey = _useActiveCell.getCellSelectionKey,
    incrementActiveCell = _useActiveCell.incrementActiveCell;
  var cellSelectionEnabled = !rowSelectionEnabled ? !!cellSelection : false;
  if (rowSelectionEnabled || hasRowNavigation) {
    computedActiveCell = undefined;
  }
  var cellNavigationEnabled = computedActiveCell !== undefined;
  if (cellSelection) {
    cellNavigationEnabled = props.enableKeyboardNavigation !== false && !hasRowNavigation ? true : computedActiveCell !== undefined || !!cellSelection;
  }
  if (props.enableKeyboardNavigation === false) {
    cellNavigationEnabled = false;
  }
  var cellMultiSelectionEnabledRef = (0, _react.useRef)(false);
  cellMultiSelectionEnabledRef.current = cellSelectionEnabled && props.multiSelect !== false;
  var cellMultiSelectionEnabled = cellMultiSelectionEnabledRef.current;
  var prevMultiSelectionEnabled = (0, _usePrevious.default)(cellMultiSelectionEnabled, cellMultiSelectionEnabled);
  (0, _react.useEffect)(function () {
    if (prevMultiSelectionEnabled && !cellMultiSelectionEnabled) {
      setCellSelection({});
    }
  }, [cellMultiSelectionEnabled, prevMultiSelectionEnabled]);
  var onCellEnter = (0, _react.useMemo)(function () {
    return listenOnCellEnter ? function (event, _ref2) {
      var columnIndex = _ref2.columnIndex,
        rowIndex = _ref2.rowIndex;
      var computedProps = computedPropsRef.current;
      if (!computedProps) {
        return;
      }
      var data = computedProps.getItemAt(rowIndex);
      if (!data || data.__group) {
        return;
      }
      var col = computedProps.getColumnBy(columnIndex);
      if (col && col.cellSelectable === false) {
        return;
      }
      var groupBy = computedProps.computedGroupBy;
      var minCol = groupBy ? groupBy.length : 0;
      if (columnIndex < minCol) {
        return;
      }
      var range = computedProps.getCellSelectionBetween(computedProps.selectionFixedCell || computedProps.computedActiveCell || computedProps.lastSelectedCell, [rowIndex, columnIndex]);
      var queue = (0, _batchUpdate.default)();
      queue(function () {
        computedProps.setCellSelection(range);
        computedProps.setLastCellInRange(Object.keys(range).pop() || '');
      });
      var direction = computedProps.cellDragStartRowIndex != null ? rowIndex - computedProps.cellDragStartRowIndex : rowIndex;
      var sign = direction < 0 ? -1 : direction > 0 ? 1 : 0;
      var scrollToRowIndex = (0, _clamp.default)(rowIndex + sign, 0, computedProps.count - 1);
      var visible = computedProps.isCellVisible({
        columnIndex: columnIndex,
        rowIndex: scrollToRowIndex
      });
      if (visible !== true) {
        visible = visible;
        var left = visible.leftDiff < 0;
        var top = visible.topDiff < 0;
        computedProps.scrollToCell({
          columnIndex: columnIndex,
          rowIndex: scrollToRowIndex
        }, {
          top: top,
          left: left
        });
      }
      queue.commit();
    } : null;
  }, [listenOnCellEnter]);
  var getContinuousSelectedRangeFor = function getContinuousSelectedRangeFor(selectionMap, cell) {
    if (!cell) {
      return [];
    }
    selectionMap = selectionMap || {};
    var _cell = (0, _slicedToArray2.default)(cell, 2),
      row = _cell[0],
      col = _cell[1];
    var key = getCellSelectionKey(row, col);
    var range = [];
    while (selectionMap[key]) {
      range.push([row, col]);
      key = getCellSelectionKey(row - 1, col - 1);
      if (selectionMap[key]) {
        row -= 1;
        col -= 1;
        continue;
      }
      if (!selectionMap[key]) {
        key = getCellSelectionKey(row - 1, col);
      }
      if (selectionMap[key]) {
        row -= 1;
        continue;
      }
      if (!selectionMap[key]) {
        key = getCellSelectionKey(row, col - 1);
        col -= 1;
      }
    }
    return range;
  };
  var toggleActiveCellSelection = (0, _react.useCallback)(function (fakeEvent) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    var computedActiveCell = computedProps.computedActiveCell;
    if (!computedActiveCell) {
      return;
    }
    var _computedActiveCell = (0, _slicedToArray2.default)(computedActiveCell, 2),
      rowIndex = _computedActiveCell[0],
      columnIndex = _computedActiveCell[1];
    var column = computedProps.getColumnBy(columnIndex);
    if (column && column.cellSelectable === false) {
      return;
    }
    var selected = isCellSelected(rowIndex, columnIndex);
    var event = fakeEvent || {
      ctrlKey: selected
    };
    computedProps.onCellClickAction(event, {
      rowIndex: rowIndex,
      columnIndex: columnIndex
    });
  }, []);
  var isCellSelected = (0, _react.useCallback)(function (row, col) {
    if (row && (0, _typeof2.default)(row) === 'object') {
      col = row.columnIndex;
      row = row.rowIndex;
    }
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    if (computedProps.computedCellSelection) {
      var key = computedProps.getCellSelectionKey(row, col);
      return !!computedProps.computedCellSelection[key];
    }
    return false;
  }, []);
  var _useState = (0, _react.useState)(null),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    cellDragStartRowIndex = _useState2[0],
    setCellDragStartRowIndex = _useState2[1];
  var cellSelectionRef = (0, _react.useRef)(cellSelection);
  cellSelectionRef.current = cellSelection;
  var onCellSelectionDraggerMouseDown = (0, _react.useMemo)(function () {
    if (cellMultiSelectionEnabled && cellSelectionRef.current) {
      var _onCellSelectionDraggerMouseDown = function _onCellSelectionDraggerMouseDown(event, _ref3, selectionFixedCell) {
        var columnIndex = _ref3.columnIndex,
          rowIndex = _ref3.rowIndex;
        var computedProps = computedPropsRef.current;
        if (!computedProps) {
          return;
        }
        var column = computedProps.getColumnBy(columnIndex);
        if (column && column.cellSelectable === false) {
          return;
        }
        if (!selectionFixedCell) {
          var currentCell = [rowIndex, columnIndex];
          var groupBy = computedProps.computedGroupBy;
          var hasGroupBy = groupBy && groupBy.length;
          var currentRange = !hasGroupBy ? getContinuousSelectedRangeFor(computedProps.computedCellSelection, currentCell) : [];
          selectionFixedCell = !hasGroupBy ? getFirstSelectedCell(currentRange.length ? currentRange : [currentCell]) : computedProps.computedActiveCell || computedProps.lastSelectedCell;
        }
        var fn = function fn() {
          computedProps.setListenOnCellEnter(false, fn);
          setCellDragStartRowIndex(null);
          computedProps.setSelectionFixedCell(null);
        };
        var queue = (0, _batchUpdate.default)();
        queue(function () {
          setCellDragStartRowIndex(rowIndex);
          if (selectionFixedCell === undefined) {
            selectionFixedCell = null;
          }
          computedProps.setSelectionFixedCell(selectionFixedCell);
          computedProps.setListenOnCellEnter(true, fn);
        });
        queue.commit();
      };
      return _onCellSelectionDraggerMouseDown;
    }
    return null;
  }, [cellMultiSelectionEnabled]);
  var cellContentRef = (0, _react.useRef)(null);
  var computedCellBulkUpdateMouseDown = (0, _react.useCallback)(function (_event, _cellProps) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    if (!computedProps.enableCellBulkUpdate) {
      return;
    }
    var computedActiveCell = computedProps.computedActiveCell,
      data = computedProps.data;
    if (!computedActiveCell) {
      return;
    }
    setBulkUpdateMouseDown(true);
    var _computedActiveCell2 = (0, _slicedToArray2.default)(computedActiveCell, 2),
      activeRow = _computedActiveCell2[0],
      activeColumn = _computedActiveCell2[1];
    var row = data[activeRow];
    var column = computedProps.getColumnBy(activeColumn);
    var columnName = column.name;
    var cellContent = columnName ? row[columnName] : null;
    cellContentRef.current = cellContent;
  }, []);
  var computedCellBulkUpdateMouseUp = (0, _react.useCallback)(function (_event) {
    setBulkUpdateMouseDown(false);
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    var cellContent = cellContentRef.current;
    if (!cellContent) {
      return;
    }
    if (!computedProps.enableCellBulkUpdate) {
      return;
    }
    var cellSelectionMap = computedProps.computedCellSelection;
    if (!cellSelectionMap) {
      return;
    }
    var dataMap = {};
    Object.keys(cellSelectionMap).map(function (key) {
      var _key$split = key.split(','),
        _key$split2 = (0, _slicedToArray2.default)(_key$split, 2),
        rowId = _key$split2[0],
        columnName = _key$split2[1];
      if (!dataMap[rowId]) {
        dataMap[rowId] = (0, _defineProperty2.default)({}, columnName, cellContent);
      }
      {
        dataMap[rowId] = _objectSpread(_objectSpread({}, dataMap[rowId]), {}, (0, _defineProperty2.default)({}, columnName, cellContent));
      }
    });
    var dataArray = Object.keys(dataMap).map(function (key) {
      var index = -1;
      index = computedProps.getItemIndexById(key);
      if (index === -1) {
        index = computedProps.getItemIndexById(Number(key));
      }
      if (index > -1) {
        var item = computedProps.getItemAt(index);
        var itemId = computedProps.getItemId(item);
        return _objectSpread({
          id: itemId
        }, dataMap[key]);
      }
    });
    computedProps.setItemsAt(dataArray, {
      replace: false
    });
    cellContentRef.current = null;
  }, []);
  return {
    onCellEnter: onCellEnter,
    toggleActiveCellSelection: toggleActiveCellSelection,
    cellDragStartRowIndex: cellDragStartRowIndex,
    setCellDragStartRowIndex: setCellDragStartRowIndex,
    onCellSelectionDraggerMouseDown: onCellSelectionDraggerMouseDown,
    computedCellBulkUpdateMouseDown: computedCellBulkUpdateMouseDown,
    bulkUpdateMouseDown: bulkUpdateMouseDown,
    computedCellBulkUpdateMouseUp: computedCellBulkUpdateMouseUp,
    getCellSelectionBetween: getCellSelectionBetween,
    computedActiveCell: computedActiveCell,
    incrementActiveCell: incrementActiveCell,
    getCellSelectionIdKey: getCellSelectionIdKey,
    setActiveCell: setActiveCell,
    getCellSelectionKey: getCellSelectionKey,
    cellSelectionEnabled: cellSelectionEnabled,
    cellNavigationEnabled: cellNavigationEnabled,
    cellMultiSelectionEnabled: cellMultiSelectionEnabled,
    computedCellSelection: cellSelection,
    setCellSelection: setCellSelection
  };
};
exports.useCellSelection = useCellSelection;