/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _useProperty5 = _interopRequireDefault(require("../useProperty"));
var _isSelectionEnabled = _interopRequireDefault(require("./isSelectionEnabled"));
var _isMultiSelect = _interopRequireDefault(require("./isMultiSelect"));
var _isSelectionControlled = _interopRequireDefault(require("./isSelectionControlled"));
var _handleSelection = require("../useRow/handleSelection");
var _batchUpdate = _interopRequireDefault(require("../../utils/batchUpdate"));
var _usePrevious = _interopRequireDefault(require("../usePrevious"));
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var EMPTY_OBJECT = {};
var getUnselectedFromProps = function getUnselectedFromProps(computedProps) {
  if (!computedProps) {
    return null;
  }
  if (computedProps.computedUnselected === undefined) {
    return null;
  }
  return computedProps.computedUnselected;
};
var getUnselectedCountFromProps = function getUnselectedCountFromProps(computedProps, unselected) {
  if (!computedProps) {
    return 0;
  }
  if (!computedProps.computedRowSelectionEnabled) {
    return 0;
  }
  if (!computedProps.computedRowMultiSelectionEnabled) {
    return 0;
  }
  unselected = unselected === undefined ? getUnselectedFromProps(computedProps) : unselected;
  return unselected ? Object.keys(unselected).length : 0;
};
var getSelectedCountFromProps = function getSelectedCountFromProps(computedProps, selected, unselected) {
  if (!computedProps) {
    return 0;
  }
  if (!computedProps.computedRowSelectionEnabled) {
    return 0;
  }
  var multiSelect = computedProps.computedRowMultiSelectionEnabled;
  selected = selected === undefined ? computedProps.computedSelected : selected;
  if (multiSelect && selected === true) {
    var unselectedCount = getUnselectedCountFromProps(computedProps, unselected);
    return computedProps.paginationCount - unselectedCount;
  }
  return multiSelect ? selected ? Object.keys(selected).length : 0 : !selected || Object.keys(selected).length === 0 ? 0 : 1;
};
var useUnselected = function useUnselected(props, _ref, _computedPropsRef) {
  var rowSelectionEnabled = _ref.rowSelectionEnabled,
    rowMultiSelectionEnabled = _ref.rowMultiSelectionEnabled;
  var _useProperty = (0, _useProperty5.default)(props, 'unselected'),
    _useProperty2 = (0, _slicedToArray2.default)(_useProperty, 2),
    unselected = _useProperty2[0],
    setUnselected = _useProperty2[1];
  if (!rowSelectionEnabled) {
    return {
      unselected: null,
      setUnselected: setUnselected
    };
  }
  if (!rowMultiSelectionEnabled) {
    return {
      unselected: null,
      setUnselected: setUnselected
    };
  }
  return {
    unselected: unselected,
    setUnselected: setUnselected
  };
};
var useSelected = function useSelected(props, _computedProps, computedPropsRef) {
  var _useProperty3 = (0, _useProperty5.default)(props, 'selected', undefined, {
      onChange: function onChange(selected) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          silent = _ref2.silent,
          unselected = _ref2.unselected,
          data = _ref2.data;
        var computedProps = computedPropsRef.current;
        if (props.onSelectionChange && !silent) {
          props.onSelectionChange({
            selected: selected,
            data: data,
            unselected: unselected !== undefined ? unselected : computedProps != null ? computedProps.computedUnselected : null
          });
        }
      }
    }),
    _useProperty4 = (0, _slicedToArray2.default)(_useProperty3, 2),
    selected = _useProperty4[0],
    setSelected = _useProperty4[1];
  var rowSelectionEnabled = (0, _isSelectionEnabled.default)(props);
  var rowMultiSelectionEnabled = (0, _isMultiSelect.default)(props);
  if (!rowSelectionEnabled) {
    return {
      selected: null,
      setSelected: setSelected,
      rowSelectionEnabled: rowSelectionEnabled,
      rowMultiSelectionEnabled: rowMultiSelectionEnabled
    };
  }
  if ((0, _isSelectionControlled.default)(props)) {
    return {
      selected: selected,
      setSelected: setSelected,
      rowSelectionEnabled: rowSelectionEnabled,
      rowMultiSelectionEnabled: rowMultiSelectionEnabled
    };
  }
  if (rowMultiSelectionEnabled && ((0, _typeof2.default)(selected) != 'object' || !selected) && selected !== true) {
    selected = EMPTY_OBJECT;
  }
  return {
    selected: selected,
    setSelected: setSelected,
    rowSelectionEnabled: rowSelectionEnabled,
    rowMultiSelectionEnabled: rowMultiSelectionEnabled
  };
};
var _default = function _default(props, computedProps, computedPropsRef) {
  var _useSelected = useSelected(props, computedProps, computedPropsRef),
    computedSelected = _useSelected.selected,
    setSelected = _useSelected.setSelected,
    rowMultiSelectionEnabled = _useSelected.rowMultiSelectionEnabled,
    rowSelectionEnabled = _useSelected.rowSelectionEnabled;
  var previousRowMultiSelectionEnabled = (0, _usePrevious.default)(rowMultiSelectionEnabled, rowMultiSelectionEnabled);
  (0, _react.useEffect)(function () {
    if (previousRowMultiSelectionEnabled === true && rowMultiSelectionEnabled === false) {
      setSelected({});
    }
  }, [previousRowMultiSelectionEnabled, rowMultiSelectionEnabled]);
  var computedRowSelectionEnabled = rowSelectionEnabled;
  var computedRowMultiSelectionEnabled = rowMultiSelectionEnabled;
  var _useUnselected = useUnselected(props, {
      rowSelectionEnabled: rowSelectionEnabled,
      rowMultiSelectionEnabled: rowMultiSelectionEnabled
    }, computedPropsRef),
    computedUnselected = _useUnselected.unselected,
    setUnselected = _useUnselected.setUnselected;
  var computedSelectedCount = getSelectedCountFromProps({
    computedPagination: computedProps.computedPagination,
    computedRemoteData: computedProps.computedRemoteData,
    paginationCount: computedProps.paginationCount,
    computedRowMultiSelectionEnabled: computedRowMultiSelectionEnabled,
    computedRowSelectionEnabled: computedRowSelectionEnabled
  }, computedSelected, computedUnselected);
  var computedUnselectedCount = getUnselectedCountFromProps({
    computedRowMultiSelectionEnabled: computedRowMultiSelectionEnabled,
    computedRowSelectionEnabled: computedRowSelectionEnabled
  }, computedUnselected);
  var isSelectionEmpty = (0, _react.useCallback)(function () {
    var selected = computedSelected;
    var selectionEmpty = false;
    if (selected == null) {
      selectionEmpty = true;
    }
    if ((0, _typeof2.default)(selected) === 'object' && selected !== null) {
      selectionEmpty = Object.keys(selected).length === 0;
    }
    return selectionEmpty;
  }, [computedSelected]);
  var getSelectedMap = (0, _react.useCallback)(function () {
    if (computedRowMultiSelectionEnabled) {
      return computedSelected;
    }
    return (0, _defineProperty2.default)({}, computedSelected, true);
  }, [computedRowMultiSelectionEnabled, computedSelected]);
  var getUnselected = (0, _react.useCallback)(function () {
    return getUnselectedFromProps(computedPropsRef.current);
  }, []);
  var getUnselectedMap = (0, _react.useCallback)(function () {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return {};
    }
    var unselected = getUnselected();
    if (computedProps.computedRowMultiSelectionEnabled) {
      return unselected || {};
    }
    return {};
  }, [getUnselected]);
  var getUnselectedCount = function getUnselectedCount(unselected) {
    return getUnselectedCountFromProps(computedPropsRef.current, unselected);
  };
  var getSelectedCount = function getSelectedCount(selected, unselected) {
    return getSelectedCountFromProps(computedPropsRef.current, selected, unselected);
  };
  var isRowSelected = (0, _react.useCallback)(function (data) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return false;
    }
    if (typeof data == 'number') {
      data = computedProps.getItemAt(data);
    }
    var selectedMap = getSelectedMap();
    var id = computedProps.getItemId(data);
    if (selectedMap === true) {
      var unselectedMap = getUnselectedMap();
      return !unselectedMap[id];
    }
    return !!selectedMap[id];
  }, [getSelectedMap, getUnselectedMap]);
  var cellSelectionTmp = props.cellSelection || props.defaultCellSelection;
  var activeCellDefined = props.activeCell !== undefined || props.defaultActiveCell !== undefined;
  var computedHasRowNavigation = (computedRowSelectionEnabled || !cellSelectionTmp) && computedProps.computedActiveIndex > -1 ? true : props.enableKeyboardNavigation !== false && !cellSelectionTmp && !activeCellDefined;
  if (props.enableKeyboardNavigation === false) {
    computedHasRowNavigation = false;
  }
  var _computedProps$useCel = computedProps.useCellSelection(props, {
      rowSelectionEnabled: rowSelectionEnabled,
      listenOnCellEnter: computedProps.listenOnCellEnter,
      hasRowNavigation: computedHasRowNavigation
    }, computedPropsRef),
    computedCellSelection = _computedProps$useCel.computedCellSelection,
    setCellSelection = _computedProps$useCel.setCellSelection,
    computedCellSelectionEnabled = _computedProps$useCel.cellSelectionEnabled,
    computedCellMultiSelectionEnabled = _computedProps$useCel.cellMultiSelectionEnabled,
    computedCellNavigationEnabled = _computedProps$useCel.cellNavigationEnabled,
    computedActiveCell = _computedProps$useCel.computedActiveCell,
    incrementActiveCell = _computedProps$useCel.incrementActiveCell,
    getCellSelectionIdKey = _computedProps$useCel.getCellSelectionIdKey,
    getCellSelectionBetween = _computedProps$useCel.getCellSelectionBetween,
    toggleActiveCellSelection = _computedProps$useCel.toggleActiveCellSelection,
    onCellEnter = _computedProps$useCel.onCellEnter,
    setActiveCell = _computedProps$useCel.setActiveCell,
    getCellSelectionKey = _computedProps$useCel.getCellSelectionKey,
    cellDragStartRowIndex = _computedProps$useCel.cellDragStartRowIndex,
    setCellDragStartRowIndex = _computedProps$useCel.setCellDragStartRowIndex,
    onCellSelectionDraggerMouseDown = _computedProps$useCel.onCellSelectionDraggerMouseDown,
    computedCellBulkUpdateMouseDown = _computedProps$useCel.computedCellBulkUpdateMouseDown,
    bulkUpdateMouseDown = _computedProps$useCel.bulkUpdateMouseDown,
    computedCellBulkUpdateMouseUp = _computedProps$useCel.computedCellBulkUpdateMouseUp;
  var selectAll = (0, _react.useCallback)(function () {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    if (!computedProps.computedRowSelectionEnabled) {
      return;
    }
    var data = computedProps.data;
    var dataMap = computedProps.dataMap;
    if (computedProps.computedGroupBy) {
      dataMap = {};
      data = data.map(function (d) {
        var id = computedProps.getItemId(d);
        dataMap[id] = id;
      });
    }
    if (computedProps.computedTreeEnabled && computedProps.stickyTreeNodes) {
      var vl = computedProps.getVirtualList();
      vl.updateStickyRows(undefined, undefined, {
        force: true
      });
    }
    (0, _handleSelection.notifySelection)(computedProps, computedProps.computedRemoteData || computedProps.computedPagination ? data.length === 0 ? false : true : dataMap, data, null);
  }, []);
  var deselectAll = (0, _react.useCallback)(function () {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    if (computedProps.computedTreeEnabled && computedProps.stickyTreeNodes) {
      var vl = computedProps.getVirtualList();
      vl.updateStickyRows(undefined, undefined, {
        force: true
      });
    }
    (0, _handleSelection.notifySelection)(computedProps, {}, [], null);
  }, []);
  var setRowSelected = (0, _react.useCallback)(function (index, selected, event) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    var queue = (0, _batchUpdate.default)();
    if (computedProps.checkboxSelectEnableShiftKey && computedProps.computedRowMultiSelectionEnabled) {
      if (event && event.target) {
        var shiftKey = event.shiftKey,
          metaKey = event.metaKey,
          ctrlKey = event.ctrlKey;
        if (shiftKey) {
          var rowProps = {
            data: computedProps.getItemAt(index),
            rowIndex: index
          };
          (0, _handleSelection.handleSelection)(rowProps, computedProps, {
            shiftKey: shiftKey,
            metaKey: metaKey,
            ctrlKey: ctrlKey
          }, queue);
          return;
        }
        computedProps.shiftKeyIndexRef.current = index;
        computedProps.selectionIndexRef.current = index;
      }
    }
    computedProps.setSelectedAt(index, selected, queue);
    queue.commit();
  }, [computedProps.initialProps.checkboxSelectEnableShiftKey]);
  var setSelectedAt = (0, _react.useCallback)(function (index, selected, queue) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    var data = computedProps.data[index];
    if (!data) {
      return;
    }
    var id = computedProps.getItemId(data);
    computedProps.setSelectedById(id, selected, queue);
  }, []);
  var treeGridChildrenSelection = function treeGridChildrenSelection(dataArray, id, selected, clone, treeGridChildrenDeselectionEnabled, parentNode) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    var idProperty = computedProps.idProperty;
    var nodesName = computedProps.nodesProperty;
    var pathSeparator = computedProps.nodePathSeparator;
    var expandedNodes = computedProps.computedExpandedNodes || EMPTY_OBJECT;
    var generateIdFromPath = computedProps.generateIdFromPath;
    for (var i = 0; i < dataArray.length; i++) {
      var item = dataArray[i];
      if (item) {
        var _id$split;
        var itemId = item[idProperty];
        var itemNodes = item[nodesName];
        var parentNodeId = parentNode ? "".concat(parentNode[idProperty]) : undefined;
        var path = parentNode ? "".concat(parentNodeId).concat(pathSeparator).concat(itemId) : "".concat(itemId);
        if (generateIdFromPath) {
          item[idProperty] = path;
        }
        var idLength = (_id$split = id.split(pathSeparator)) === null || _id$split === void 0 ? void 0 : _id$split.length;
        var idFromPath = path.split(pathSeparator).slice(0, idLength).join(pathSeparator);
        if (idFromPath === id) {
          var treeData = computedProps.dataMap ? computedProps.dataMap[path] : null;
          if (!treeData) {
            continue;
          }
          if (selected) {
            clone[path] = treeData;
          } else {
            if (treeGridChildrenDeselectionEnabled) {
              delete clone[path];
            } else {
              delete clone[id];
            }
          }
        }
        if (expandedNodes && expandedNodes[idFromPath]) {
          if (Array.isArray(itemNodes)) {
            treeGridChildrenSelection(itemNodes, id, selected, clone, treeGridChildrenDeselectionEnabled, item);
          }
        }
      }
    }
    return clone;
  };
  var groupChildrenSelection = function groupChildrenSelection(_ref4) {
    var clone = _ref4.clone,
      id = _ref4.id,
      selected = _ref4.selected,
      dataMap = _ref4.dataMap,
      idProperty = _ref4.idProperty;
    if (!dataMap) {
      return;
    }
    for (var key in dataMap) {
      if (!key) {
        break;
      }
      if (!key.includes(id)) {
        continue;
      }
      var data = dataMap[key];
      if (data.__group) {
        if (selected) {
          if (!clone[key]) {
            clone[key] = data;
          }
        } else {
          delete clone[key];
        }
        if (data.array && Array.isArray(data.array)) {
          var _iterator = _createForOfIteratorHelper(data.array),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              var itemId = item[idProperty];
              if (selected) {
                if (!clone[itemId]) clone[itemId] = item;
              } else {
                delete clone[itemId];
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } else {
        var dataId = data[idProperty];
        if (dataId === id) {
          if (selected) {
            if (!clone[id]) clone[id] = data;
          } else {
            delete clone[id];
          }
        }
      }
    }
    return clone;
  };
  var setSelectedById = (0, _react.useCallback)(function (id, selected, queue) {
    var computedProps = computedPropsRef.current;
    if (!computedProps) {
      return;
    }
    var data = computedProps.dataMap ? computedProps.dataMap[id] : null;
    if (!data) {
      return;
    }
    var isSelected = computedProps.isRowSelected(data);
    var multiSelect = computedProps.computedRowMultiSelectionEnabled;
    if (isSelected === selected) {
      return;
    }
    if (multiSelect) {
      var selectedMap = computedProps.computedSelected;
      var unselectedMap = selectedMap === true ? computedProps.computedUnselected || {} : null;
      var clone = selectedMap;
      if (selectedMap === true) {
        if (unselectedMap) {
          unselectedMap = Object.assign({}, unselectedMap);
        }
        if (!selected && unselectedMap) {
          unselectedMap[id] = true;
          var totalCount = computedProps.paginationCount;
          if (Object.keys(unselectedMap).length === totalCount) {
            computedProps.deselectAll();
            return;
          }
        } else {
          if (unselectedMap) {
            delete unselectedMap[id];
          }
          if (getUnselectedCountFromProps(computedProps, unselectedMap) === 0) {
            unselectedMap = null;
          }
        }
      } else {
        clone = Object.assign({}, selectedMap);
        if (computedProps.computedTreeEnabled && computedProps.treeGridChildrenSelectionEnabled) {
          var originalData = JSON.stringify(computedProps.originalData || []);
          var cloneOriginalData = (0, _toConsumableArray2.default)(JSON.parse(originalData));
          var treeGridChildrenDeselectionEnabled = computedProps.treeGridChildrenDeselectionEnabled;
          treeGridChildrenSelection(cloneOriginalData, id, selected, clone, treeGridChildrenDeselectionEnabled);
        } else if (computedProps.groupColumn) {
          groupChildrenSelection({
            clone: clone,
            id: id,
            selected: selected,
            dataMap: computedProps.dataMap,
            idProperty: computedProps.idProperty
          });
        } else {
          if (selected) {
            clone[id] = data;
          } else {
            delete clone[id];
          }
        }
      }
      (0, _handleSelection.notifySelection)(computedProps, clone, data, unselectedMap, queue);
    } else {
      (0, _handleSelection.notifySelection)(computedProps, selected ? id : null, data, null, queue);
    }
  }, []);
  return {
    selectAll: selectAll,
    deselectAll: deselectAll,
    setRowSelected: setRowSelected,
    setSelectedAt: setSelectedAt,
    setSelectedById: setSelectedById,
    setCellSelection: setCellSelection,
    computedCellSelection: computedCellSelection,
    computedCellSelectionEnabled: computedCellSelectionEnabled,
    computedCellMultiSelectionEnabled: computedCellMultiSelectionEnabled,
    computedCellNavigationEnabled: computedCellNavigationEnabled,
    computedActiveCell: computedActiveCell,
    getCellSelectionBetween: getCellSelectionBetween,
    incrementActiveCell: incrementActiveCell,
    cellDragStartRowIndex: cellDragStartRowIndex,
    setCellDragStartRowIndex: setCellDragStartRowIndex,
    onCellEnter: onCellEnter,
    onCellSelectionDraggerMouseDown: onCellSelectionDraggerMouseDown,
    toggleActiveCellSelection: toggleActiveCellSelection,
    computedHasRowNavigation: computedHasRowNavigation,
    computedRowSelectionEnabled: computedRowSelectionEnabled,
    computedRowMultiSelectionEnabled: computedRowMultiSelectionEnabled,
    computedSelected: computedSelected,
    setSelected: setSelected,
    computedUnselected: computedUnselected,
    setUnselected: setUnselected,
    isSelectionEmpty: isSelectionEmpty,
    getSelectedMap: getSelectedMap,
    getUnselectedMap: getUnselectedMap,
    isRowSelected: isRowSelected,
    getUnselectedCount: getUnselectedCount,
    getSelectedCount: getSelectedCount,
    computedUnselectedCount: computedUnselectedCount,
    computedSelectedCount: computedSelectedCount,
    getCellSelectionIdKey: getCellSelectionIdKey,
    setActiveCell: setActiveCell,
    getCellSelectionKey: getCellSelectionKey,
    computedCellBulkUpdateMouseDown: computedCellBulkUpdateMouseDown,
    computedCellBulkUpdateMouseUp: computedCellBulkUpdateMouseUp,
    bulkUpdateMouseDown: bulkUpdateMouseDown
  };
};
exports.default = _default;