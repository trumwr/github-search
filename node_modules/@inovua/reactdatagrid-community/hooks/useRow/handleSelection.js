/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.notifySelection = exports.handleSingleSelection = exports.handleSelection = exports.handleMultiSelectionRowToggle = exports.handleMultiSelection = exports.findInitialSelectionIndex = void 0;
var _isControlledProperty = _interopRequireDefault(require("../../utils/isControlledProperty"));
var _batchUpdate = _interopRequireDefault(require("../../utils/batchUpdate"));
var _getGlobal = require("../../getGlobal");
var globalObject = (0, _getGlobal.getGlobal)();
var ua = globalObject.navigator ? globalObject.navigator.userAgent : '';
var isSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
var delay35 = function delay35(fn) {
  return function () {
    return setTimeout(fn, 35);
  };
};
var now = function now(fn) {
  return function () {
    return fn();
  };
};
var findInitialSelectionIndex = function findInitialSelectionIndex(computedProps) {
  var selected = computedProps.getSelectedMap();
  var index = null;
  if (!selected || !Object.keys(selected).length) {
    return index;
  }
  var i = 0;
  var data = computedProps.data;
  var len = data.length;
  var id;
  for (; i < len; i++) {
    id = computedProps.getItemId(data[i]);
    if (selected[id]) {
      index = i;
    }
  }
  return index;
};
exports.findInitialSelectionIndex = findInitialSelectionIndex;
var notifySelection = function notifySelection(computedProps, selected, data, unselected, queue) {
  var queueDefined = !!queue;
  queue = queue || (0, _batchUpdate.default)();
  var onSelectionChange = (isSafari ? delay35 : now)(function () {
    if (typeof computedProps.onSelectionChange == 'function') {
      computedProps.onSelectionChange({
        selected: selected,
        data: data,
        unselected: unselected,
        originalData: (computedProps === null || computedProps === void 0 ? void 0 : computedProps.originalData) || null
      });
    }
  });
  if (!(0, _isControlledProperty.default)(computedProps.initialProps, 'unselected')) {
    queue(function () {
      computedProps.setUnselected(unselected);
    });
  }
  if (!(0, _isControlledProperty.default)(computedProps.initialProps, 'selected')) {
    queue(function () {
      computedProps.setSelected(selected, {
        silent: true
      });
    });
  }
  onSelectionChange();
  if (!queueDefined) {
    queue.commit();
  }
};
exports.notifySelection = notifySelection;
var handleSingleSelection = function handleSingleSelection(rowProps, computedProps, event, queue) {
  var data = rowProps.data;
  var rowSelected = computedProps.isRowSelected(data);
  var newSelected = !rowSelected;
  var ctrlKey = event.metaKey || event.ctrlKey;
  if (!computedProps.toggleRowSelectOnClick && rowSelected && event && !ctrlKey) {
    newSelected = true;
  }
  var selectedId = newSelected ? computedProps.getItemId(data) : null;
  notifySelection(computedProps, selectedId, data, null, queue);
};
exports.handleSingleSelection = handleSingleSelection;
var handleMultiSelection = function handleMultiSelection(computedProps, data, config, queue) {
  var selIndex = config.selIndex;
  var prevShiftKeyIndex = config.prevShiftKeyIndex;
  var map = selIndex == null ? {} : Object.assign({}, computedProps.computedSelected);
  if (prevShiftKeyIndex != null && selIndex != null) {
    var min = Math.min(prevShiftKeyIndex, selIndex);
    var max = Math.max(prevShiftKeyIndex, selIndex);
    var removeArray = computedProps.data.slice(min, max + 1) || [];
    removeArray.forEach(function (item) {
      if (item) {
        var id = computedProps.getItemId(item);
        delete map[id];
      }
    });
  }
  data.forEach(function (item) {
    if (item) {
      var id = computedProps.getItemId(item);
      map[id] = item;
    }
  });
  notifySelection(computedProps, map, data, null, queue);
};
exports.handleMultiSelection = handleMultiSelection;
var handleMultiSelectionRowToggle = function handleMultiSelectionRowToggle(computedProps, data, queue) {
  var selected = computedProps.computedSelected;
  var isSelected = computedProps.isRowSelected(data);
  if (selected !== true) {
    var clone = Object.assign({}, selected);
    var id = computedProps.getItemId(data);
    if (isSelected) {
      delete clone[id];
    } else {
      clone[id] = data;
    }
    notifySelection(computedProps, clone, data, null, queue);
  } else {
    var _id = computedProps.getItemId(data);
    var unselected = Object.assign({}, computedProps.computedUnselected);
    if (isSelected) {
      unselected[_id] = data;
    } else {
      delete unselected[_id];
    }
    notifySelection(computedProps, true, data, unselected, queue);
  }
  return isSelected;
};
exports.handleMultiSelectionRowToggle = handleMultiSelectionRowToggle;
var handleSelection = function handleSelection(rowProps, computedProps, event, queue) {
  var queueDefined = !!queue;
  if (!queue) {
    queue = (0, _batchUpdate.default)();
  }
  if (!computedProps.computedRowSelectionEnabled) {
    return;
  }
  if (!computedProps.computedRowMultiSelectionEnabled) {
    handleSingleSelection(rowProps, computedProps, event, queue);
    if (!queueDefined) {
      queue.commit();
    }
    return;
  }
  var selIndex = computedProps.selectionIndexRef.current;
  if (selIndex === null) {
    selIndex = findInitialSelectionIndex(computedProps);
  }
  var index = rowProps.rowIndex;
  var prevShiftKeyIndex = computedProps.shiftKeyIndexRef.current;
  var start;
  var end;
  var data;
  if (event.metaKey || event.ctrlKey || computedProps.toggleRowSelectOnClick && computedProps.getSelectedCount() === 1 && computedProps.isRowSelected(computedProps.data[index])) {
    computedProps.selectionIndexRef.current = index;
    computedProps.shiftKeyIndexRef.current = null;
    var unselect = handleMultiSelectionRowToggle(computedProps, computedProps.data[index], queue);
    if (!queueDefined) {
      queue.commit();
    }
    if (unselect) {
      computedProps.selectionIndexRef.current++;
      computedProps.shiftKeyIndexRef.current = prevShiftKeyIndex;
      return false;
    }
    return;
  }
  if (!event.shiftKey) {
    computedProps.selectionIndexRef.current = index;
    computedProps.shiftKeyIndexRef.current = null;
    selIndex = null;
  } else {
    computedProps.shiftKeyIndexRef.current = index;
  }
  if (selIndex == null) {
    data = [computedProps.data[index]];
  } else {
    start = Math.min(index, selIndex);
    end = Math.max(index, selIndex) + 1;
    data = computedProps.data.slice(start, end);
  }
  handleMultiSelection(computedProps, data, {
    selIndex: selIndex,
    prevShiftKeyIndex: prevShiftKeyIndex
  }, queue);
  if (!queueDefined) {
    queue.commit();
  }
};
exports.handleSelection = handleSelection;