/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _filter = _interopRequireDefault(require("../../filter"));
var _treeFilter = _interopRequireDefault(require("../../treeFilter"));
var _paginate = _interopRequireDefault(require("../../utils/paginate"));
var _getFilterValueForColumns = _interopRequireDefault(require("./getFilterValueForColumns"));
var _getSortInfoForColumns = _interopRequireDefault(require("./getSortInfoForColumns"));
var _excluded = ["originalData"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var filterData = function filterData(data, _ref, config) {
  var filterValue = _ref.filterValue,
    remoteFilter = _ref.remoteFilter,
    filterTypes = _ref.filterTypes,
    columnsMap = _ref.columnsMap;
  if (!Array.isArray(filterValue) || !filterValue.length) {
    return data;
  }
  if (remoteFilter) {
    return data;
  }
  var filterValueForColumns = (0, _getFilterValueForColumns.default)(filterValue, columnsMap);
  if (!filterValueForColumns.length) {
    return data;
  }
  if (config.treeEnabled) {
    return (0, _treeFilter.default)(data, filterValueForColumns, filterTypes, columnsMap, {
      props: config.computedProps
    });
  }
  return (0, _filter.default)(data, filterValueForColumns, filterTypes, columnsMap);
};
var flow = function flow(_ref2) {
  var originalData = _ref2.originalData,
    rest = (0, _objectWithoutProperties2.default)(_ref2, _excluded);
  var input = _objectSpread(_objectSpread({}, rest), {}, {
    data: originalData,
    originalData: originalData,
    previousData: []
  });
  for (var _len = arguments.length, transforms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    transforms[_key - 1] = arguments[_key];
  }
  return transforms.reduce(function (acc, transform) {
    acc = transform(acc);
    acc.previousData.push(acc.data);
    return acc;
  }, input);
};
var computeData = function computeData(config, computedProps, batchUpdateQueue) {
  var columnsMap = computedProps.columnsMap;
  var originalData = config.originalData || computedProps.originalData;
  var dataCountAfterFilter = undefined;
  var loading = config.loading === undefined ? computedProps.computedLoading : config.loading;
  var filterValue = config.filterValue === undefined ? computedProps.computedFilterValue : config.filterValue;
  var remoteFilter = config.remoteFilter === undefined ? computedProps.computedRemoteFilter : config.remoteFilter;
  var dataSourceCache = config.dataSourceCache === undefined ? computedProps.computedDataSourceCache : config.dataSourceCache;
  var filterTypes = computedProps.filterTypes;
  var localPagination = config.localPagination === undefined ? computedProps.computedLocalPagination : config.localPagination;
  var remoteData = config.remoteData === undefined ? computedProps.computedRemoteData : config.remoteData;
  var sortInfo = config.sortInfo === undefined ? computedProps.computedSortInfo : config.sortInfo;
  var skip = config.skip === undefined ? computedProps.computedSkip : config.skip;
  var limit = config.limit === undefined ? computedProps.computedLimit : config.limit;
  var groupBy = config.groupBy === undefined ? computedProps.computedGroupBy : config.groupBy;
  var treeEnabled = computedProps.computedTreeEnabled;
  var pivot = computedProps.pivot;
  var computedSummary = !!computedProps.summaryReducer;
  if (remoteData) {
    return {
      data: undefined,
      dataCountAfterFilter: dataCountAfterFilter
    };
  }
  var result = flow({
    originalData: originalData
  }, function (config) {
    if (dataSourceCache && Object.keys(dataSourceCache).length) {
      config.data = config.data.map(function (item) {
        var id = computedProps.getItemId(item);
        if (dataSourceCache[id]) {
          item = _objectSpread(_objectSpread({}, item), dataSourceCache[id]);
        }
        return item;
      });
    }
    return config;
  }, function (config) {
    if (filterValue && !computedProps.filterValue) {
      filterValue = (0, _getFilterValueForColumns.default)(filterValue, columnsMap);
      config.data = filterData(config.data, {
        filterValue: filterValue,
        filterTypes: filterTypes,
        remoteFilter: remoteFilter,
        columnsMap: columnsMap
      }, {
        treeEnabled: treeEnabled,
        computedProps: computedProps
      });
    }
    dataCountAfterFilter = config.data.length;
    return config;
  }, function (config) {
    if (!computedProps.sortInfo) {
      sortInfo = (0, _getSortInfoForColumns.default)(sortInfo, columnsMap);
      if (sortInfo && computedProps.sorty) {
        config.data = (0, _toConsumableArray2.default)(config.data);
        computedProps.sorty(sortInfo, config.data);
      }
    }
    return config;
  }, function (config) {
    if (treeEnabled && computedProps.computeTreeData) {
      var expandedNodes = computedProps.computedExpandedNodes;
      config.data = computedProps.computeTreeData(config.data, {
        expandedNodes: expandedNodes,
        isNodeLeaf: computedProps.isNodeLeaf,
        isNodeAsync: computedProps.isNodeAsync,
        pathSeparator: computedProps.nodePathSeparator,
        loadingNodes: computedProps.computedLoadingNodes,
        nodesName: computedProps.nodesProperty,
        nodeCache: computedProps.computedNodeCache,
        dataSourceCache: computedProps.computedDataSourceCache,
        generateIdFromPath: computedProps.generateIdFromPath,
        collapsingNodes: computedProps.collapsingNodesRef.current,
        idProperty: !computedProps.compoundIdProperty ? computedProps.idProperty : 'id'
      });
    }
    dataCountAfterFilter = config.data.length;
    return config;
  }, function (config) {
    if (computedSummary) {
      var summary = computedProps.summaryReducer.initialValue;
      var reducerFn = computedProps.summaryReducer.reducer || computedProps.summaryReducer.reduce;
      if (summary && (0, _typeof2.default)(summary) === 'object') {
        summary = _objectSpread({}, summary);
      }
      var data = config.data;
      var item;
      for (var i = 0, len = data.length; i < len; i++) {
        item = data[i];
        summary = reducerFn(summary, item, computedProps);
      }
      if (computedProps.summaryReducer.complete) {
        summary = computedProps.summaryReducer.complete(summary, data || [], computedProps);
      }
      batchUpdateQueue(function () {
        computedProps.setSummary(summary);
      });
    }
    return config;
  }, function (config) {
    if (localPagination && limit) {
      skip = skip || 0;
      config.data = (0, _paginate.default)(config.data, {
        skip: skip,
        limit: limit
      });
    }
    return config;
  }, function (config) {
    batchUpdateQueue(function () {
      computedProps.setUngroupedData(config.data);
    });
    var length = config.data.length;
    if (Array.isArray(groupBy) && groupBy.length && computedProps.computeDataStep && length) {
      config = computedProps.computeDataStep({
        groupBy: groupBy,
        batchUpdateQueue: batchUpdateQueue,
        columnsMap: columnsMap,
        computedProps: computedProps,
        config: config
      });
    }
    return config;
  });
  return {
    data: result.data,
    dataCountAfterFilter: dataCountAfterFilter || 0
  };
};
var _default = computeData;
exports.default = _default;