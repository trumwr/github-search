/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateFilters = exports.hasTypeOperators = exports.hasTypeOperator = exports.default = exports.checkForEmptyValue = exports.buildTypeOperators = exports.buildFilterParam = void 0;
var _filterTypes = _interopRequireDefault(require("./filterTypes"));
var buildTypeOperators = function buildTypeOperators(filterTypes) {
  return Object.keys(filterTypes).reduce(function (acc, filterTypeName) {
    var filterType = filterTypes[filterTypeName];
    if (!filterType || !filterType.operators) {
      return acc;
    }
    var operators = filterType.operators.reduce(function (operatorAccumulator, operator) {
      operatorAccumulator[operator.name] = operator;
      return operatorAccumulator;
    }, {});
    acc[filterTypeName] = operators;
    return acc;
  }, {});
};
exports.buildTypeOperators = buildTypeOperators;
var buildFilterParam = function buildFilterParam(item, fv) {
  var filterTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _filterTypes.default;
  var columnsMap = arguments.length > 3 ? arguments[3] : undefined;
  var filterParam = {};
  var name = fv.name,
    getFilterValue = fv.getFilterValue,
    filterValue = fv.value,
    type = fv.type;
  filterParam.emptyValue = fv.hasOwnProperty('emptyValue') ? fv.emptyValue : filterTypes[type].emptyValue;
  filterParam.filterValue = filterValue;
  if (columnsMap) {
    filterParam.column = columnsMap[name];
  }
  filterParam.data = item;
  filterParam.value = typeof getFilterValue === 'function' ? getFilterValue({
    data: item,
    value: item[name]
  }) : item[name];
  return filterParam;
};
exports.buildFilterParam = buildFilterParam;
var hasTypeOperators = function hasTypeOperators(fn, currentTypeOperators, type) {
  if (!fn && !currentTypeOperators) {
    console.error("No filter of type \"".concat(type, "\" found!"));
    return true;
  }
  return false;
};
exports.hasTypeOperators = hasTypeOperators;
var hasTypeOperator = function hasTypeOperator(fn, currentTypeOperators, type, operator) {
  if (!fn && !currentTypeOperators[operator]) {
    console.error("No operator \"".concat(operator, "\" found for filter type \"").concat(type, "\"!"));
    return true;
  }
  return false;
};
exports.hasTypeOperator = hasTypeOperator;
var checkForEmptyValue = function checkForEmptyValue(filterValue, emptyValue, filterOnEmptyValue) {
  if (filterValue === emptyValue && !filterOnEmptyValue) {
    return true;
  }
  return false;
};
exports.checkForEmptyValue = checkForEmptyValue;
var validateFilters = function validateFilters(fv) {
  var _currentTypeOperators;
  var filterTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _filterTypes.default;
  var currentTypeOperators = arguments.length > 2 ? arguments[2] : undefined;
  var active = fv.active,
    fn = fv.fn,
    type = fv.type,
    operator = fv.operator;
  var emptyValue = fv.hasOwnProperty('emptyValue') ? fv.emptyValue : filterTypes[type].emptyValue;
  var filterOnEmptyValue = currentTypeOperators ? (_currentTypeOperators = currentTypeOperators[operator]) === null || _currentTypeOperators === void 0 ? void 0 : _currentTypeOperators.filterOnEmptyValue : undefined;
  if (active === false) {
    return true;
  }
  if (!filterTypes[type]) {
    return true;
  }
  if (hasTypeOperators(fn, currentTypeOperators, type)) {
    return true;
  }
  if (hasTypeOperator(fn, currentTypeOperators, type, operator)) {
    return true;
  }
  if (checkForEmptyValue(fv.value, emptyValue, filterOnEmptyValue)) {
    return true;
  }
  return false;
};
exports.validateFilters = validateFilters;
var doFilter = function doFilter(item, filterValueArray) {
  var filterTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _filterTypes.default;
  var columnsMap = arguments.length > 3 ? arguments[3] : undefined;
  var typeOperators = buildTypeOperators(filterTypes);
  for (var i = 0, len = filterValueArray.length; i < len; i++) {
    var fv = filterValueArray[i];
    var type = fv.type,
      operator = fv.operator,
      fn = fv.fn;
    var currentTypeOperators = typeOperators[type];
    if (validateFilters(fv, filterTypes, currentTypeOperators)) {
      continue;
    }
    var filterParam = buildFilterParam(item, fv, filterTypes, columnsMap);
    var filterFn = fn || currentTypeOperators[operator].fn;
    if (filterFn(filterParam) !== true) {
      return false;
    }
  }
  return true;
};
var filter = function filter(data, filterValueArray, filterTypes, columnsMap) {
  filterTypes = filterTypes || _filterTypes.default;
  var filterFn = function filterFn(item) {
    var result = doFilter(item, filterValueArray, filterTypes, columnsMap);
    return result;
  };
  if (data === undefined) {
    return filterFn;
  }
  return data.filter(filterFn);
};
var _default = filter;
exports.default = _default;