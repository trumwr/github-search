/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _reactClass = _interopRequireDefault(require("../../../packages/react-class"));
var _debounce = _interopRequireDefault(require("../../../packages/debounce"));
var _contains = _interopRequireDefault(require("../../../packages/contains"));
var _assignDefined2 = _interopRequireDefault(require("../../../packages/assign-defined"));
var _region = _interopRequireDefault(require("../../../packages/region"));
var _isMobile = _interopRequireDefault(require("../../../packages/isMobile"));
var _getRangesForBoxes = _interopRequireDefault(require("./getRangesForBoxes"));
var _getRangesForColumns = _interopRequireDefault(require("./getRangesForColumns"));
var _setupColumnDrag = _interopRequireDefault(require("./setupColumnDrag"));
var _moveXBeforeY = _interopRequireDefault(require("../../../utils/moveXBeforeY"));
var _isFocusable = _interopRequireDefault(require("../../../utils/isFocusable"));
var _getDropIndex2 = _interopRequireDefault(require("./getDropIndex"));
var _getUndraggableSuccessiveCount = _interopRequireDefault(require("./getUndraggableSuccessiveCount"));
var _DragCell = _interopRequireWildcard(require("./DragCell"));
var _DragHeaderGroup = _interopRequireDefault(require("./DragHeaderGroup"));
var _HeaderWrapper = _interopRequireDefault(require("./HeaderWrapper"));
var _Header = require("./Header");
var _getScrollbarWidth = _interopRequireDefault(require("../../../packages/getScrollbarWidth"));
var _getGlobal = require("../../../getGlobal");
var _join = _interopRequireDefault(require("@inovua/reactdatagrid-community/packages/join"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var globalObject = (0, _getGlobal.getGlobal)();
var SCROLL_MARGIN = 40;
var DRAG_INFO = null;
var preventDefault = function preventDefault(e) {
  return e.preventDefault();
};
var getColumnOrder = function getColumnOrder(props, filter) {
  var doFilter = function doFilter(c) {
    return !c.groupColumn && filter ? filter(c) : true;
  };
  var order;
  if (props.computedColumnOrder) {
    order = props.computedColumnOrder.map(function (id) {
      return props.columnsMap[id];
    }).filter(Boolean);
  } else {
    order = props.allColumns;
  }
  var toId = function toId(c) {
    return c.id;
  };
  order = (order || []).filter(doFilter).map(toId);
  var lockedStart = props.lockedStartColumns.filter(doFilter).map(toId);
  var lockedMap = lockedStart.reduce(function (acc, cId) {
    acc[cId] = true;
    return acc;
  }, {});
  var lockedEnd = props.lockedEndColumns.filter(doFilter).map(toId);
  lockedEnd.reduce(function (acc, cId) {
    acc[cId] = true;
    return acc;
  }, lockedMap);
  return [].concat((0, _toConsumableArray2.default)(lockedStart), (0, _toConsumableArray2.default)(order.filter(function (cId) {
    return !lockedMap[cId];
  })), (0, _toConsumableArray2.default)(lockedEnd));
};
var getParentsForColumns = function getParentsForColumns(columns, groups, maxDepth) {
  var parentsForColumns = columns.map(function (col) {
    var result = [col.id].concat((0, _toConsumableArray2.default)((0, _Header.getParentGroups)(col.group, groups, {
      includeSelf: true
    }).map(function (g) {
      return g.name;
    })));
    while (result.length <= maxDepth + 1) {
      result.splice(0, 0, result[0]);
    }
    return result;
  });
  return parentsForColumns;
};
var getValidDropPositions = function getValidDropPositions(_ref) {
  var dragTargetDepth = _ref.dragTargetDepth,
    dragTargetIndex = _ref.dragTargetIndex,
    dragTargetLength = _ref.dragTargetLength,
    parentsForColumns = _ref.parentsForColumns,
    lockedForColumns = _ref.lockedForColumns,
    columns = _ref.columns,
    allowGroupSplitOnReorder = _ref.allowGroupSplitOnReorder;
  var getGroupsForColumn = function getGroupsForColumn(parents) {
    parents = parents || [];
    var initialName = parents[0];
    var shouldCheck = true;
    var groups = [];
    parents.forEach(function (group) {
      if (!shouldCheck) {
        groups.push(group);
        return;
      }
      if (shouldCheck && group !== initialName) {
        shouldCheck = false;
        groups.push(group);
        return;
      }
      groups.push(null);
    });
    return groups;
  };
  var getGroupStartFor = function getGroupStartFor(parents, depth, index) {
    var initialParent = parents[index].slice(-depth - 1)[0];
    var initialLocked = lockedForColumns[index];
    var itParents;
    var currentParent;
    var currentLocked;
    do {
      itParents = parents[index - 1];
      if (!itParents) {
        break;
      }
      currentParent = itParents.slice(-depth - 1)[0];
      currentLocked = lockedForColumns[index];
      if (currentParent !== initialParent || currentLocked !== initialLocked) {
        break;
      }
      index--;
    } while (index >= 0);
    return index;
  };
  var getGroupEndFor = function getGroupEndFor(parents, depth, index) {
    var initialParent = parents[index].slice(-depth - 1)[0];
    var initialLocked = lockedForColumns[index];
    var itParents;
    var currentParent;
    var currentLocked;
    do {
      index++;
      itParents = parents[index];
      if (!itParents) {
        break;
      }
      currentParent = itParents.slice(-depth - 1)[0];
      currentLocked = lockedForColumns[index];
      if (currentParent !== initialParent || currentLocked !== initialLocked) {
        break;
      }
    } while (index < parents.length);
    return index;
  };
  var res = columns.reduce(function (acc, col, index) {
    if (index > dragTargetIndex && index <= dragTargetIndex + dragTargetLength) {
      return acc;
    }
    acc[index] = true;
    return acc;
  }, {});
  res[columns.length] = true;
  if (!allowGroupSplitOnReorder) {
    var dragTargetParentGroups = getGroupsForColumn(parentsForColumns[dragTargetIndex]).filter(function (x) {
      return x;
    });
    var isSingleColumn = !dragTargetParentGroups.length;
    var usedDepth = isSingleColumn ? 0 : dragTargetDepth;
    var parentGroupStartIndex = !usedDepth ? 0 : getGroupStartFor(parentsForColumns, usedDepth - 1, dragTargetIndex);
    var parentGroupEndIndex = !usedDepth ? columns.length : getGroupEndFor(parentsForColumns, usedDepth - 1, dragTargetIndex);
    var currentGroupEndIndex = getGroupEndFor(parentsForColumns, usedDepth, dragTargetIndex);
    for (var i = 0; i <= columns.length; i++) {
      delete res[i];
    }
    for (var _i = parentGroupStartIndex; _i < parentGroupEndIndex; _i++) {
      var itGroupStartIndex = getGroupStartFor(parentsForColumns, usedDepth, _i);
      var itGroupEndIndex = getGroupEndFor(parentsForColumns, usedDepth, _i);
      res[itGroupStartIndex] = true;
      res[itGroupEndIndex] = true;
    }
    var groupEndIsLastUnlocked = columns[currentGroupEndIndex] && columns[currentGroupEndIndex].computedLocked === 'end' && columns[currentGroupEndIndex - 1] && columns[currentGroupEndIndex - 1].computedLocked !== 'end';
    if (!groupEndIsLastUnlocked) {
      delete res[currentGroupEndIndex];
    }
  }
  return res;
};
var ReorderArrow = function (_React$Component) {
  (0, _inherits2.default)(ReorderArrow, _React$Component);
  var _super = _createSuper(ReorderArrow);
  function ReorderArrow(props) {
    var _this;
    (0, _classCallCheck2.default)(this, ReorderArrow);
    _this = _super.call(this, props);
    _this.state = {
      visible: false,
      bottom: 0,
      top: 0,
      left: 0
    };
    return _this;
  }
  (0, _createClass2.default)(ReorderArrow, [{
    key: "set",
    value: function set(_ref2) {
      var bottom = _ref2.bottom,
        top = _ref2.top,
        left = _ref2.left,
        right = _ref2.right,
        target = _ref2.target;
      this.setState({
        target: target,
        bottom: bottom,
        left: left,
        top: top,
        right: right
      });
    }
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      if (visible != this.state.visible) {
        this.setState({
          visible: visible
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var size = this.props.size;
      var _this$state = this.state,
        bottom = _this$state.bottom,
        top = _this$state.top,
        left = _this$state.left,
        right = _this$state.right,
        visible = _this$state.visible,
        target = _this$state.target;
      return _react.default.createElement("div", {
        ref: this.refReorderArrow,
        style: {
          position: 'absolute',
          top: top,
          left: left,
          right: right,
          width: size,
          height: bottom - top,
          bottom: bottom,
          pointerEvents: 'none',
          opacity: visible ? 1 : 0,
          display: 'block'
        },
        className: "InovuaReactDataGrid__column-reorder-arrow InovuaReactDataGrid__column-reorder-arrow--direction-".concat(this.props.rtl ? 'rtl' : 'ltr')
      }, _react.default.createElement("div", {
        className: "InovuaReactDataGrid__column-reorder-arrow-fill InovuaReactDataGrid__column-reorder-arrow-fill--direction-".concat(this.props.rtl ? 'rtl' : 'ltr', " InovuaReactDataGrid__column-reorder-arrow-fill--target-").concat(target || 'none')
      }), this.props.renderReorderIndicator());
    }
  }]);
  return ReorderArrow;
}(_react.default.Component);
ReorderArrow.defaultProps = {
  renderReorderIndicator: function renderReorderIndicator() {}
};
var InovuaDataGridHeaderLayout = function (_Component) {
  (0, _inherits2.default)(InovuaDataGridHeaderLayout, _Component);
  var _super2 = _createSuper(InovuaDataGridHeaderLayout);
  function InovuaDataGridHeaderLayout(props) {
    var _this2;
    (0, _classCallCheck2.default)(this, InovuaDataGridHeaderLayout);
    _this2 = _super2.call(this, props);
    _this2.state = {
      draggingProps: null
    };
    _this2.refDragGroupItem = function (item) {
      _this2.dragGroupItem = item;
    };
    _this2.refDragCell = function (cell) {
      _this2.dragCell = cell;
    };
    _this2.refDragHeaderGroup = function (item) {
      _this2.dragHeaderGroup = item;
    };
    _this2.groupToolbar = (0, _react.createRef)();
    _this2.refHeader = function (h) {
      _this2.headerNode = null;
      if (h) {
        _this2.headerNode = h.getDOMNode ? h.getDOMNode() : null;
        if (!_this2.headerNode) {
          throw 'Cannot find header node';
        }
        if (_isMobile.default) {
          _this2.headerNode.addEventListener('touchmove', preventDefault);
        }
      } else {
        if (_this2.headerNode && _isMobile.default) {
          _this2.headerNode.removeEventListener('touchmove', preventDefault);
        }
        _this2.headerNode = null;
      }
      _this2.header = h;
    };
    _this2.headerWrapper = (0, _react.createRef)();
    _this2.refReorderArrow = function (cmp) {
      _this2.reorderArrow = cmp;
    };
    _this2.headerDomNode = (0, _react.createRef)();
    _this2.lazyNotifyHeaderScrollLeftMax = (0, _debounce.default)(_this2.notifyHeaderScrollLeftMax, 150);
    return _this2;
  }
  (0, _createClass2.default)(InovuaDataGridHeaderLayout, [{
    key: "notifyHeaderScrollLeftMax",
    value: function notifyHeaderScrollLeftMax(scrollLeftMax) {
      if (this.header && this.props.lockedEndColumns) {
        this.header.notifyScrollLeftMax(scrollLeftMax === undefined ? this.getScrollLeftMax() : scrollLeftMax);
      }
    }
  }, {
    key: "onContainerScrollHorizontal",
    value: function onContainerScrollHorizontal(scrollLeft, scrollLeftMax) {
      this.scrollLeft = scrollLeft;
      if (this.header) {
        this.header.setScrollLeft(scrollLeft, scrollLeftMax);
        this.lazyNotifyHeaderScrollLeftMax();
      }
    }
  }, {
    key: "setScrollLeft",
    value: function setScrollLeft(scrollLeft) {
      this.props.setScrollLeft(scrollLeft);
    }
  }, {
    key: "getScrollLeft",
    value: function getScrollLeft() {
      return this.scrollLeft || 0;
    }
  }, {
    key: "getScrollLeftMax",
    value: function getScrollLeftMax() {
      return this.props.getScrollLeftMax();
    }
  }, {
    key: "setColumnRenderStartIndex",
    value: function setColumnRenderStartIndex(columnRenderStartIndex) {
      if (this.header) {
        this.header.setColumnRenderStartIndex(columnRenderStartIndex);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var className = (0, _join.default)('InovuaReactDataGrid__header-layout', this.props.stickyHeader && 'InovuaReactDataGrid__header-layout__sticky-header');
      return _react.default.createElement("div", {
        ref: this.headerDomNode,
        className: className
      }, this.renderGroupToolbar(), this.renderHeaderWrapper(), this.renderDragCell(), this.renderDragGroupItem(), this.renderDragHeaderGroup(), this.renderReorderIndicator());
    }
  }, {
    key: "renderGroupToolbar",
    value: function renderGroupToolbar() {
      var _this$props = this.props,
        columnsMap = _this$props.columnsMap,
        onGroupByChange = _this$props.onGroupByChange,
        onHeaderSortClick = _this$props.onHeaderSortClick,
        renderGroupItem = _this$props.renderGroupItem,
        renderSortTool = _this$props.renderSortTool,
        renderGroupToolbar = _this$props.renderGroupToolbar,
        groupBy = _this$props.computedGroupBy,
        disableGroupByToolbar = _this$props.disableGroupByToolbar,
        i18n = _this$props.i18n,
        rtl = _this$props.rtl,
        theme = _this$props.theme;
      if (!groupBy || !renderGroupToolbar) {
        return null;
      }
      return renderGroupToolbar({
        columnsMap: columnsMap,
        groupBy: groupBy,
        rtl: rtl,
        theme: theme,
        renderSortTool: renderSortTool,
        onGroupByChange: onGroupByChange,
        disableGroupByToolbar: disableGroupByToolbar,
        renderGroupItem: renderGroupItem,
        headerGroupPlaceholderText: i18n('dragHeaderToGroup'),
        onItemMouseDown: this.onGroupItemMouseDown,
        onSortClick: onHeaderSortClick,
        ref: this.groupToolbar
      });
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      var props = this.props;
      var computedShowHeader = props.computedShowHeader;
      if (!computedShowHeader) {
        return null;
      }
      var scrollLeft = (this.scrollLeft !== undefined ? this.scrollLeft : props.scrollLeft) || 0;
      var groupBy = this.props.computedGroupBy && this.props.computedGroupBy.length ? this.props.computedGroupBy : null;
      return _react.default.createElement(_HeaderWrapper.default, _objectSpread(_objectSpread({}, props), {}, {
        groupBy: groupBy,
        onHeaderGroupMouseDown: this.onHeaderGroupMouseDown,
        onHeaderCellMouseDown: this.onHeaderCellMouseDown,
        onHeaderCellTouchStart: this.onHeaderCellTouchStart,
        ref: this.headerWrapper,
        refHeader: this.refHeader,
        scrollLeft: scrollLeft,
        setScrollLeft: this.setScrollLeft
      }));
    }
  }, {
    key: "renderDragCell",
    value: function renderDragCell() {
      return _react.default.createElement(_DragCell.default, {
        ref: this.refDragCell
      });
    }
  }, {
    key: "renderDragGroupItem",
    value: function renderDragGroupItem() {
      if (!this.props.renderDragGroupItem) {
        return null;
      }
      return this.props.renderDragGroupItem(this.refDragGroupItem);
    }
  }, {
    key: "renderDragHeaderGroup",
    value: function renderDragHeaderGroup() {
      if (!this.props.computedGroups) {
        return;
      }
      return _react.default.createElement(_DragHeaderGroup.default, {
        ref: this.refDragHeaderGroup
      });
    }
  }, {
    key: "onGroupItemMouseDown",
    value: function onGroupItemMouseDown(column, index, event) {
      this.onHeaderCellMouseDown(column, event, {
        dragTarget: 'group',
        dragIndex: index
      });
    }
  }, {
    key: "getCellDOMNodeAt",
    value: function getCellDOMNodeAt(index) {
      return this.header.getCellDOMNodeAt(index);
    }
  }, {
    key: "getHeader",
    value: function getHeader() {
      return this.header;
    }
  }, {
    key: "onHeaderGroupMouseDown",
    value: function onHeaderGroupMouseDown(event, headerGroupProps, headerGroup) {
      if (event.ctrlKey || event.metaKey) {
        return;
      }
      if (this._dragIndex !== undefined) {
        return;
      }
      if (headerGroupProps.group && headerGroupProps.group.draggable === false) {
        return;
      }
      var dragTargetNode = headerGroup.domRef ? headerGroup.domRef.current : null;
      var shouldStop = (0, _toConsumableArray2.default)(dragTargetNode.querySelectorAll('.InovuaReactDataGrid__column-header__filter-wrapper')).reduce(function (shouldStop, filterWrapperNode) {
        if ((0, _contains.default)(filterWrapperNode, event.target) || filterWrapperNode === event.target) {
          return true;
        }
        return shouldStop;
      }, false);
      if (shouldStop) {
        return;
      }
      var groupColumns = headerGroupProps.columns.reduce(function (acc, colId) {
        acc[colId] = true;
        return acc;
      }, {});
      this.groupColumns = groupColumns;
      var dragBoxes = this.header.getGroupsAndCells().filter(function (item) {
        if (item === headerGroup) {
          return true;
        }
        if (item.props.id in groupColumns) {
          return false;
        }
        return !item.props.isHeaderGroup;
      });
      var dragIndex = dragBoxes.indexOf(headerGroup);
      var dragTargetIndex = this.props.columnsMap[headerGroup.props.columns[0]].computedVisibleIndex;
      var dragTargetDepth = headerGroup.props.depth;
      var dragTargetLength = headerGroup.props.columns.length;
      var parentsForColumns = getParentsForColumns(this.props.visibleColumns, this.props.computedGroupsMap, this.props.computedGroupsDepth);
      this.maybeDragMouseDown(event, {
        dragTarget: 'headergroup',
        dragTargetIndex: dragTargetIndex,
        dragTargetDepth: dragTargetDepth,
        dragTargetLength: dragTargetLength,
        parentsForColumns: parentsForColumns,
        dragTargetNode: dragTargetNode,
        dragIndex: dragIndex,
        dragBoxes: dragBoxes,
        allowTargetChange: false,
        ranges: (0, _getRangesForBoxes.default)(dragBoxes, function (i) {
          return i;
        })
      });
    }
  }, {
    key: "onHeaderCellTouchStart",
    value: function onHeaderCellTouchStart() {
      return this.onHeaderCellMouseDown.apply(this, arguments);
    }
  }, {
    key: "onHeaderCellMouseDown",
    value: function onHeaderCellMouseDown(_ref3, event) {
      var visibleIndex = _ref3.computedVisibleIndex;
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
          dragTarget: 'header'
        },
        _ref4$dragTarget = _ref4.dragTarget,
        dragTarget = _ref4$dragTarget === void 0 ? 'header' : _ref4$dragTarget,
        dragIndex = _ref4.dragIndex;
      if (this.props.reorderColumns === false) {
        return;
      }
      if ((0, _isFocusable.default)(event.target)) {
        return;
      }
      if (event.nativeEvent.which == 3 || event.metaKey || event.ctrlKey) {
        return;
      }
      if (dragIndex === undefined) {
        dragIndex = visibleIndex;
      }
      if (event.ctrlKey || event.metaKey) {
        return;
      }
      var allowTargetChange = undefined;
      var dragColumn;
      var dragTargetNode = this.getCellDOMNodeAt(visibleIndex);
      if (dragTarget == 'header') {
        dragColumn = this.props.visibleColumns[visibleIndex];
        if (!dragColumn || dragColumn.groupColumn || dragColumn.draggable === false) {
          event.stopPropagation();
          return;
        }
        if (this.props.computedGroupBy) {
          if (this.props.computedGroupBy.indexOf(dragColumn.id) != -1 || this.props.computedGroupBy.indexOf(dragColumn.name) != -1) {
            allowTargetChange = false;
          }
        }
        if (dragColumn.draggable === false) {
          return;
        }
        if (dragColumn.groupBy === false) {
          allowTargetChange = false;
        }
      }
      var dragTargetIndex = dragIndex;
      var dragTargetDepth = dragColumn && dragColumn.group && this.props.computedGroupsMap && this.props.computedGroupsMap[dragColumn.group] ? this.props.computedGroupsMap[dragColumn.group].computedDepth + 1 : this.props.computedGroupsDepth + 1;
      var parentsForColumns = getParentsForColumns(this.props.visibleColumns, this.props.computedGroupsMap, this.props.computedGroupsDepth);
      this.maybeDragMouseDown(event, {
        dragTarget: dragTarget,
        dragIndex: dragIndex,
        dragTargetNode: dragTargetNode,
        parentsForColumns: parentsForColumns,
        dragTargetIndex: dragTargetIndex,
        dragTargetDepth: dragTargetDepth,
        dragTargetLength: 1,
        allowTargetChange: allowTargetChange
      });
    }
  }, {
    key: "maybeDragMouseDown",
    value: function maybeDragMouseDown(event, _ref5) {
      var _this3 = this;
      var dragTarget = _ref5.dragTarget,
        dragIndex = _ref5.dragIndex,
        allowTargetChange = _ref5.allowTargetChange,
        ranges = _ref5.ranges,
        parentsForColumns = _ref5.parentsForColumns,
        dragTargetIndex = _ref5.dragTargetIndex,
        dragTargetDepth = _ref5.dragTargetDepth,
        dragTargetNode = _ref5.dragTargetNode,
        dragTargetLength = _ref5.dragTargetLength;
      if (this.props.computedPivot) {
        return;
      }
      this._dragIndex = dragIndex;
      var _removeListeners;
      var mouseMoveEventCount = 0;
      var didSetupDrag = false;
      var cleanup = function cleanup() {
        delete _this3._dragIndex;
        if (_removeListeners) {
          _removeListeners();
        }
      };
      var onMouseUp = cleanup;
      var onMouseMove = function onMouseMove(event) {
        if (didSetupDrag) {
          return;
        }
        mouseMoveEventCount++;
        if (mouseMoveEventCount > 1) {
          didSetupDrag = true;
          _removeListeners();
          _this3.setupDrag({
            dragTarget: dragTarget,
            dragIndex: dragIndex,
            allowTargetChange: allowTargetChange,
            ranges: ranges,
            parentsForColumns: parentsForColumns,
            dragTargetIndex: dragTargetIndex,
            dragTargetDepth: dragTargetDepth,
            dragTargetLength: dragTargetLength,
            dragTargetNode: dragTargetNode
          }, event);
        }
      };
      var mouseup = _isMobile.default ? 'touchend' : 'mouseup';
      var mousemove = _isMobile.default ? 'touchmove' : 'mousemove';
      _removeListeners = function removeListeners() {
        _removeListeners = null;
        globalObject.removeEventListener(mouseup, onMouseUp, false);
        globalObject.removeEventListener(mousemove, onMouseMove, false);
      };
      if (_isMobile.default) {
        setTimeout(function () {
          onMouseUp();
        }, 350);
      }
      globalObject.addEventListener(mouseup, onMouseUp, false);
      globalObject.addEventListener(mousemove, onMouseMove, false);
    }
  }, {
    key: "renderReorderIndicator",
    value: function renderReorderIndicator() {
      var size = this.props.reorderProxySize;
      return _react.default.createElement(ReorderArrow, {
        ref: this.refReorderArrow,
        size: size,
        rtl: this.props.rtl,
        renderReorderIndicator: this.props.renderReorderIndicator
      });
    }
  }, {
    key: "setReorderArrowAt",
    value: function setReorderArrowAt(index, ranges, target) {
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var visible = arguments.length > 4 ? arguments[4] : undefined;
      visible = visible !== undefined ? visible : index != DRAG_INFO.dragIndex || target != DRAG_INFO.dragTarget;
      if (offset) {
        visible = true;
      }
      var rtl = this.props.rtl;
      this.reorderArrow.setVisible(visible);
      var last = index == ranges.length;
      var box = ranges[index];
      var _DRAG_INFO = DRAG_INFO,
        headerRegion = _DRAG_INFO.headerRegion,
        initialScrollLeft = _DRAG_INFO.initialScrollLeft;
      if (!box && last) {
        var _box;
        var lastBox = ranges[ranges.length - 1] || {
          left: headerRegion.left,
          right: headerRegion.left
        };
        box = (_box = {}, (0, _defineProperty2.default)(_box, rtl ? 'right' : 'left', rtl ? lastBox.left : lastBox.right), (0, _defineProperty2.default)(_box, "computedLocked", lastBox.computedLocked), _box);
      }
      box = box || (rtl ? {
        right: 0
      } : {
        left: 0
      });
      var boxPos = rtl ? box.right : box.left;
      if (rtl && this.props.nativeScroll && this.props.scrollbars.vertical) {
        boxPos -= (0, _getScrollbarWidth.default)();
      }
      return this.setReorderArrowPosition(rtl ? -boxPos + headerRegion.right - offset : boxPos - headerRegion.left + offset, target);
    }
  }, {
    key: "setReorderArrowPosition",
    value: function setReorderArrowPosition(pos, target) {
      var rtl = this.props.rtl;
      this.reorderArrowPosition = this.reorderArrowPosition || {};
      (0, _assignDefined2.default)(this.reorderArrowPosition, (0, _defineProperty2.default)({}, rtl ? 'right' : 'left', pos));
      this.reorderArrow.set(_objectSpread((0, _defineProperty2.default)({
        target: target
      }, rtl ? 'right' : 'left', rtl ? this.reorderArrowPosition.right : this.reorderArrowPosition.left), DRAG_INFO.reorderProxyPosition[target]));
      return this;
    }
  }, {
    key: "setReorderArrowVisible",
    value: function setReorderArrowVisible(visible) {
      this.reorderArrow.setVisible(visible);
      return this;
    }
  }, {
    key: "getGroupToolbar",
    value: function getGroupToolbar() {
      return this.groupToolbar.current;
    }
  }, {
    key: "getGroupByItems",
    value: function getGroupByItems() {
      if (!this.groupToolbar.current) {
        return null;
      }
      return this.groupToolbar.current.getSortedItemsInfo();
    }
  }, {
    key: "getHeaderCells",
    value: function getHeaderCells() {
      return this.header.getCells();
    }
  }, {
    key: "getBoxesFor",
    value: function getBoxesFor(target) {
      if (target == 'header') {
        return this.header.getCells();
      }
      if (target == 'group' && this.groupToolbar.current) {
        return this.groupToolbar.current.getCells();
      }
      if (target == 'headergroup') {
        return this.header.getGroupsAndCells();
      }
      return [];
    }
  }, {
    key: "getDragBoxInstance",
    value: function getDragBoxInstance(dragIndex, dragTarget, dragTargetDepth, dragTargetLength) {
      if (dragTarget === 'group') {
        return this.getGroupToolbar() && this.getGroupToolbar().getCells()[dragIndex];
      }
      var dragCell = this.getHeaderCells()[dragIndex];
      var dragBox = dragCell;
      if (dragTargetLength) {
        var cellProps = dragCell.getProps();
        while (cellProps.depth > dragTargetDepth) {
          if (cellProps.parent) {
            dragBox = cellProps.parent;
            cellProps = dragBox.props;
          } else {
            break;
          }
        }
      }
      return dragBox;
    }
  }, {
    key: "setupDrag",
    value: function setupDrag(_ref6, event) {
      var _DRAG_INFO2;
      var dragTarget = _ref6.dragTarget,
        dragIndex = _ref6.dragIndex,
        _ref6$allowTargetChan = _ref6.allowTargetChange,
        allowTargetChange = _ref6$allowTargetChan === void 0 ? true : _ref6$allowTargetChan,
        parentsForColumns = _ref6.parentsForColumns,
        dragTargetIndex = _ref6.dragTargetIndex,
        dragTargetDepth = _ref6.dragTargetDepth,
        dragTargetLength = _ref6.dragTargetLength;
      var columns = this.props.visibleColumns;
      var rtl = this.props.rtl;
      var headerRegion = _region.default.from(this.headerDomNode.current);
      var dragBox = this.getDragBoxInstance(dragIndex, dragTarget, dragTargetDepth, dragTargetLength);
      var initialScrollLeft = this.getScrollLeft();
      var dragBoxProps = dragBox.getProps ? dragBox.getProps() : dragBox.props;
      var rtlOffset = Math.max(this.props.totalComputedWidth - this.props.size.width, 0);
      var columnRanges = (0, _getRangesForColumns.default)(columns, {
        rtl: rtl,
        rtlOffset: rtlOffset,
        initialOffset: rtl ? headerRegion.right : headerRegion.left,
        headerRegion: headerRegion,
        initialScrollLeft: initialScrollLeft,
        availableWidth: Math.min(this.props.availableWidth, this.props.totalComputedWidth),
        totalLockedEndWidth: this.props.totalLockedEndWidth
      });
      var groupToolbarCells = this.getGroupToolbar() && this.getGroupToolbar().getCells();
      var groupByRanges = this.props.computedGroupBy && this.props.computedGroupBy.length ? (0, _getRangesForBoxes.default)(groupToolbarCells) || [] : [];
      var dragProxy = dragTarget == 'header' ? this.dragCell : dragTarget == 'group' ? this.dragGroupItem : this.dragHeaderGroup;
      var dragColumn = dragTarget === 'group' ? dragBoxProps.column : columns[dragIndex];
      var headerDragColumn = dragTarget == 'header' ? dragColumn : null;
      var columnId = dragTarget == 'header' ? headerDragColumn.id : dragTarget == 'group' ? dragColumn.id : null;
      var dragBoxNode = dragBox.getDOMNode ? dragBox.getDOMNode() : null;
      var dragBoxInitialRegion = dragBox && dragBox.getProxyRegion ? dragBox.getProxyRegion() : _region.default.from(dragBoxNode);
      if (_DragCell.MAX_WIDTH && dragBoxInitialRegion.getWidth() > _DragCell.MAX_WIDTH) {
        dragBoxInitialRegion.setWidth(_DragCell.MAX_WIDTH);
      }
      if (_region.default.from(dragBoxNode).getWidth() > headerRegion.getWidth() / 2) {
        if (rtl) {
          dragBoxInitialRegion.shift({
            right: event.pageX - dragBoxInitialRegion.right - this.props.columnReorderScrollByAmount
          });
        } else {
          dragBoxInitialRegion.shift({
            left: event.pageX - dragBoxInitialRegion.left - this.props.columnReorderScrollByAmount
          });
        }
      }
      var dragBoxOffsets = (0, _defineProperty2.default)({
        top: headerRegion.top
      }, rtl ? 'right' : 'left', rtl ? headerRegion.right : headerRegion.left);
      var extendedDragBoxProps = _objectSpread({}, dragBoxProps);
      if (this.props.renderColumnReorderProxy) {
        Object.assign(extendedDragBoxProps, {
          renderColumnReorderProxy: this.props.renderColumnReorderProxy
        });
      }
      dragProxy.setProps(extendedDragBoxProps);
      var dragProxyPosition = (0, _defineProperty2.default)({
        top: dragBoxInitialRegion.top - dragBoxOffsets.top
      }, rtl ? 'right' : 'left', rtl ? dragBoxOffsets.right - dragBoxInitialRegion.right : dragBoxInitialRegion.left - dragBoxOffsets.left);
      dragProxy.setHeight(dragBoxInitialRegion.height);
      dragProxy.setWidth(dragBoxInitialRegion.width);
      dragProxy.setTop(dragProxyPosition.top);
      if (rtl) {
        dragProxy.setRight(dragProxyPosition.right);
      } else {
        dragProxy.setLeft(dragProxyPosition.left);
      }
      var maxHeaderIndex = columns.length - (0, _getUndraggableSuccessiveCount.default)((0, _toConsumableArray2.default)(columns).reverse());
      var minHeaderIndex = (0, _getUndraggableSuccessiveCount.default)(columns);
      var validDropPositions = columns.reduce(function (acc, col, i) {
        acc[i] = true;
        return acc;
      }, {});
      validDropPositions[columns.length] = true;
      if (this.props.groups && this.props.groups.length && !this.props.allowGroupSplitOnReorder) {
        validDropPositions = getValidDropPositions({
          dragTargetDepth: dragTargetDepth,
          dragTargetIndex: dragTargetIndex,
          dragTargetLength: dragTargetLength,
          parentsForColumns: parentsForColumns,
          lockedForColumns: columns.map(function (c) {
            return c.computedLocked;
          }),
          columns: columns,
          allowGroupSplitOnReorder: this.props.allowGroupSplitOnReorder,
          maxDepth: this.props.computedGroupsDepth + 1
        });
      }
      if (validDropPositions && !validDropPositions[dragIndex] && dragTarget != 'group') {
        validDropPositions[dragIndex] = true;
      }
      var wrapperNode = this.headerDomNode ? this.headerDomNode.current : null;
      var filterRowHeight = 0;
      if (this.props.computedFilterable) {
        var filterWrapperNode = wrapperNode.querySelector('.InovuaReactDataGrid__column-header__filter-wrapper');
        if (filterWrapperNode) {
          filterRowHeight = filterWrapperNode.offsetHeight;
        }
      }
      DRAG_INFO = (_DRAG_INFO2 = {
        allowTargetChange: allowTargetChange,
        columnId: columnId,
        headerRegion: headerRegion,
        headerDragColumn: headerDragColumn,
        minHeaderIndex: minHeaderIndex,
        maxHeaderIndex: maxHeaderIndex,
        dragColumn: dragColumn,
        dragColumnsIds: dragTarget == 'headergroup' ? dragBox.props.columns : null,
        dragBox: dragBox,
        dragBoxInitialRegion: dragBoxInitialRegion,
        dragBoxRegion: dragBoxInitialRegion.clone(),
        dragBoxProps: dragBoxProps,
        dragBoxOffsets: dragBoxOffsets,
        dragProxy: dragProxy,
        dragProxyInitialPosition: dragProxyPosition,
        dragTarget: dragTarget,
        dropTarget: dragTarget,
        dragIndex: dragIndex,
        columnRanges: columnRanges,
        groupByRanges: groupByRanges,
        parentsForColumns: parentsForColumns,
        dragTargetIndex: dragTargetIndex,
        dragTargetDepth: dragTargetDepth,
        dragTargetLength: dragTargetLength,
        scrollLeftMax: this.props.getScrollLeftMax(),
        initialScrollLeft: initialScrollLeft
      }, (0, _defineProperty2.default)(_DRAG_INFO2, "headerRegion", headerRegion), (0, _defineProperty2.default)(_DRAG_INFO2, "validDropPositions", validDropPositions), _DRAG_INFO2);
      var groupToolbarNode = this.groupToolbar.current ? this.groupToolbar.current.domRef ? this.groupToolbar.current.domRef.current : null : null;
      var headerGroupTargetNode = wrapperNode;
      var groupTargetNode = groupToolbarNode || this.headerDomNode.current;
      var groupComputedStyle = getComputedStyle(groupTargetNode);
      DRAG_INFO.reorderProxyPosition = {
        group: {
          top: parseInt(groupComputedStyle.paddingTop),
          bottom: groupTargetNode.offsetHeight - parseInt(groupComputedStyle.paddingBottom)
        },
        header: {
          top: this.props.computedGroupBy ? groupToolbarNode ? groupTargetNode.offsetHeight : this.headerDomNode.current.offsetTop : 0,
          bottom: headerGroupTargetNode.offsetHeight - filterRowHeight
        },
        headergroup: {
          top: this.props.computedGroupBy ? groupToolbarNode ? groupTargetNode.offsetHeight : this.headerDomNode.current.offsetTop : 0,
          bottom: headerGroupTargetNode.offsetHeight - filterRowHeight
        }
      };
      this.setReorderArrowAt(dragIndex, dragTarget === 'group' ? groupByRanges : columnRanges, dragTarget);
      this.setReorderArrowPosition(undefined, dragTarget);
      dragProxy.setDragging(true);
      this.props.coverHandleRef.current.setActive(true);
      this.props.coverHandleRef.current.setCursor('grabbing');
      var headerNode = this.headerDomNode ? this.headerDomNode.current : null;
      (0, _setupColumnDrag.default)({
        constrainTo: this.props.constrainReorder ? _region.default.from(headerNode.parentNode) : undefined,
        region: dragBoxInitialRegion
      }, {
        onDrag: this.onHeaderCellDrag,
        onDrop: this.onHeaderCellDrop
      }, event);
    }
  }, {
    key: "onHeaderCellDrop",
    value: function onHeaderCellDrop() {
      var _this4 = this;
      this.props.coverHandleRef.current.setActive(false);
      delete this._dragIndex;
      var dropIndex = this.dropIndex,
        props = this.props;
      if (dropIndex === undefined || !DRAG_INFO) {
        if (DRAG_INFO) {
          DRAG_INFO.dragProxy.setDragging(false);
        }
        this.setReorderArrowVisible(false);
        DRAG_INFO = null;
        return;
      }
      var _DRAG_INFO3 = DRAG_INFO,
        dragColumn = _DRAG_INFO3.dragColumn,
        columnId = _DRAG_INFO3.columnId,
        dragColumnsIds = _DRAG_INFO3.dragColumnsIds,
        dragTarget = _DRAG_INFO3.dragTarget,
        dropTarget = _DRAG_INFO3.dropTarget,
        dragProxy = _DRAG_INFO3.dragProxy,
        newLocked = _DRAG_INFO3.newLocked;
      var _DRAG_INFO4 = DRAG_INFO,
        dragIndex = _DRAG_INFO4.dragIndex;
      DRAG_INFO = null;
      this.setReorderArrowVisible(false);
      dragProxy.setDragging(false);
      var columns = this.props.visibleColumns;
      var currentLocked = columns[dragIndex].computedLocked;
      if (dropIndex == dragIndex && newLocked === currentLocked && dragTarget == dropTarget) {
        return;
      }
      if (this.props.virtualizeColumns) {
        setTimeout(function () {
          _this4.header.updateColumns();
        }, 10);
      }
      if (dragTarget == 'headergroup') {
        if (dropIndex == dragIndex && dragTarget == dropTarget && newLocked === currentLocked) {
          return;
        }
        if (columns[dropIndex]) {
          this.moveColumnsBeforeIndex(dragColumnsIds, columns[dropIndex].computedVisibleIndex, newLocked);
        } else if (dropIndex == columns.length) {
          var col = columns[columns.length - 1];
          if (col) {
            this.moveColumnsBeforeIndex(dragColumnsIds, col.computedVisibleIndex + 1, newLocked);
          }
        }
        return;
      }
      var visibleColumns = props.visibleColumns,
        groupBy = props.computedGroupBy;
      if (dropTarget == dragTarget) {
        if (dragTarget == 'group') {
          this.setGroupBy((0, _moveXBeforeY.default)(groupBy, dragIndex, dropIndex));
        }
        if (dragTarget == 'header') {
          this.moveColumnsBeforeIndex([columnId], dropIndex, newLocked);
        }
      }
      if (dragTarget == 'header' && dropTarget == 'group') {
        var groupByColumn = visibleColumns[dragIndex];
        var newGroupBy = [].concat(groupBy);
        newGroupBy.splice(dropIndex, 0, groupByColumn.id);
        this.setGroupBy(newGroupBy);
      }
      if (dragTarget == 'group' && dropTarget == 'header') {
        this.ungroupColumnToIndex(columnId, dropIndex);
      }
    }
  }, {
    key: "ungroupColumnToIndex",
    value: function ungroupColumnToIndex(columnId, dropIndex) {
      var props = this.props;
      var allColumns = props.allColumns,
        visibleColumns = props.visibleColumns;
      var dragColumn = allColumns.filter(function (c) {
        return c.id === columnId;
      })[0];
      var newGroupBy = [].concat(this.props.computedGroupBy).filter(function (g) {
        return g != columnId;
      });
      var columnAtDropIndex = visibleColumns[dropIndex];
      if (columnAtDropIndex && columnAtDropIndex.id === columnId) {
        this.setGroupBy(newGroupBy);
        return;
      }
      var order = getColumnOrder(props, function (c) {
        return c.id !== columnId;
      });
      var insertIndex = columnAtDropIndex ? order.indexOf(columnAtDropIndex.id) : order.length;
      order.splice(insertIndex, 0, columnId);
      var columnAtDropIndexOrLast = columnAtDropIndex || visibleColumns[visibleColumns.length - 1];
      if (columnAtDropIndexOrLast.computedLocked != dragColumn.computedLocked) {
        this.props.setColumnLocked(columnId, columnAtDropIndexOrLast.computedLocked);
      }
      this.setGroupBy(newGroupBy);
      this.setColumnOrder(order);
    }
  }, {
    key: "moveColumnsBeforeIndex",
    value: function moveColumnsBeforeIndex(columnsIds, dropIndex, newLocked) {
      var _this5 = this;
      var props = this.props;
      var visibleColumns = props.visibleColumns,
        columnVisibilityMap = props.columnVisibilityMap,
        allowGroupSplitOnReorder = props.allowGroupSplitOnReorder;
      var columnOrder = getColumnOrder(props);
      var columns = visibleColumns.filter(function (col) {
        return columnsIds.indexOf(col.id) != -1;
      });
      var dragColumnsIndexesInAllColumns = columnsIds.map(function (columnId) {
        return columnOrder.indexOf(columnId);
      });
      var dropBeforeIndexInAllColumns = visibleColumns[dropIndex] ? columnOrder.indexOf(visibleColumns[dropIndex].id) : columnOrder.length;
      var firstDragIndex = dragColumnsIndexesInAllColumns[0];
      if (!allowGroupSplitOnReorder && firstDragIndex < dropBeforeIndexInAllColumns) {
        while (true) {
          var columnRightBefore = columnOrder[dropBeforeIndexInAllColumns - 1];
          if (columnRightBefore && columnVisibilityMap[columnRightBefore] === false) {
            dropBeforeIndexInAllColumns--;
            continue;
          }
          break;
        }
      }
      var targetColumn = visibleColumns[dropIndex] || visibleColumns[visibleColumns.length - 1];
      columns.forEach(function (col) {
        if (newLocked != col.computedLocked) {
          _this5.props.setColumnLocked(col.id, newLocked);
        }
      });
      var newColumnOrder = (0, _moveXBeforeY.default)(columnOrder, dragColumnsIndexesInAllColumns, dropBeforeIndexInAllColumns);
      this.setColumnOrder(newColumnOrder);
    }
  }, {
    key: "onHeaderCellDrag",
    value: function onHeaderCellDrag(_ref7) {
      var diffLeft = _ref7.left,
        diffTop = _ref7.top;
      if (!DRAG_INFO) {
        return;
      }
      var _DRAG_INFO5 = DRAG_INFO,
        allowTargetChange = _DRAG_INFO5.allowTargetChange,
        dragTarget = _DRAG_INFO5.dragTarget,
        dragIndex = _DRAG_INFO5.dragIndex,
        dragProxy = _DRAG_INFO5.dragProxy,
        dragColumn = _DRAG_INFO5.dragColumn,
        dragBoxInitialRegion = _DRAG_INFO5.dragBoxInitialRegion,
        dragBoxOffsets = _DRAG_INFO5.dragBoxOffsets,
        dragBoxRegion = _DRAG_INFO5.dragBoxRegion,
        groupByRanges = _DRAG_INFO5.groupByRanges,
        theRanges = _DRAG_INFO5.columnRanges,
        headerRegion = _DRAG_INFO5.headerRegion,
        scrollLeftMax = _DRAG_INFO5.scrollLeftMax,
        initialScrollLeft = _DRAG_INFO5.initialScrollLeft,
        validDropPositions = _DRAG_INFO5.validDropPositions;
      dragBoxRegion.set({
        left: dragBoxInitialRegion.left,
        top: dragBoxInitialRegion.top,
        bottom: dragBoxInitialRegion.bottom,
        right: dragBoxInitialRegion.right
      });
      var _DRAG_INFO6 = DRAG_INFO,
        dropTarget = _DRAG_INFO6.dropTarget;
      var _this$props2 = this.props,
        columnReorderScrollByAmount = _this$props2.columnReorderScrollByAmount,
        rtl = _this$props2.rtl;
      var scrollLeft = this.getScrollLeft();
      var scrollDiff = scrollLeft - initialScrollLeft;
      var initialDiffLeft = diffLeft;
      dragBoxRegion.shift({
        top: diffTop,
        left: diffLeft
      });
      diffLeft += scrollDiff;
      var minScrollLeft = Math.max(headerRegion.left, 0);
      var maxScrollRight = headerRegion.right;
      var groupToolbarNode = this.groupToolbar && this.groupToolbar.current && this.groupToolbar.current.domRef ? this.groupToolbar.current.domRef.current : null;
      if (this.groupToolbar.current && allowTargetChange) {
        var groupToolbarRegion = _region.default.from(groupToolbarNode);
        if (dragBoxRegion.top + dragBoxRegion.height / 2 < groupToolbarRegion.bottom) {
          if (dropTarget !== 'group' && dragColumn.groupBy !== false) {
            dropTarget = DRAG_INFO.dropTarget = 'group';
          }
        } else {
          if (dropTarget != 'header') {
            dropTarget = DRAG_INFO.dropTarget = 'header';
          }
        }
      }
      var scrollAdjust = 0;
      var dragProxyAdjust = 0;
      var dragComputedLocked = this.props.visibleColumns[dragIndex].computedLocked;
      if (dropTarget == 'header' || dropTarget == 'headergroup') {
        if (dragBoxInitialRegion.left + initialDiffLeft - this.props.totalLockedStartWidth < minScrollLeft + SCROLL_MARGIN && initialDiffLeft < 0) {
          scrollAdjust = -columnReorderScrollByAmount;
        } else if (dragBoxInitialRegion.right + initialDiffLeft > maxScrollRight - SCROLL_MARGIN - this.props.totalLockedEndWidth && initialDiffLeft > 0) {
          scrollAdjust = columnReorderScrollByAmount;
        }
        if (scrollAdjust) {
          if (scrollLeft + scrollAdjust < 0) {
            scrollAdjust = -scrollLeft;
          }
          if (scrollLeft + scrollAdjust > scrollLeftMax) {
            scrollAdjust = scrollLeftMax - scrollLeft;
          }
          if (scrollAdjust) {
            this.setScrollLeft(scrollLeft + scrollAdjust);
            dragProxyAdjust = scrollAdjust;
          }
        }
      }
      if (rtl) {
        dragProxy.setRight(dragBoxOffsets.right + -initialDiffLeft - dragBoxInitialRegion.right - dragProxyAdjust);
      } else {
        dragProxy.setLeft(dragBoxInitialRegion.left + initialDiffLeft - dragBoxOffsets.left - dragProxyAdjust);
      }
      dragProxy.setTop(dragBoxRegion.top - dragBoxOffsets.top);
      var dir = dropTarget == 'group' && dragTarget == 'group' ? initialDiffLeft < 0 ? -1 : 1 : dragTarget != dropTarget || diffLeft < 0 ? -1 : 1;
      if (dragComputedLocked) {
        dir = initialDiffLeft < 0 ? -1 : 1;
      }
      if (rtl) {
        dir *= -1;
      }
      var mapRange = function mapRange(r) {
        if (!r.computedLocked) {
          return _objectSpread(_objectSpread({}, r), {}, {
            left: r.left - scrollDiff,
            right: r.right - scrollDiff
          });
        }
        return r;
      };
      var currentRanges = dropTarget === 'group' ? groupByRanges : theRanges;
      var ranges = currentRanges.map(mapRange);
      var compareRanges = currentRanges.map(mapRange);
      var dragMinIndex = dropTarget == 'header' ? DRAG_INFO.minHeaderIndex : undefined;
      var dragMaxIndex = dropTarget == 'header' ? DRAG_INFO.maxHeaderIndex : undefined;
      var dropIndex;
      var _getDropIndex = (0, _getDropIndex2.default)({
          dir: dir,
          rtl: rtl,
          dragMinIndex: dragMinIndex,
          dragMaxIndex: dragMaxIndex,
          dragTarget: dragTarget,
          dropTarget: dropTarget,
          dragRange: _objectSpread(_objectSpread({}, ranges[dragIndex]), {}, {
            left: dragBoxRegion.left,
            right: dragBoxRegion.right,
            index: dragIndex
          }),
          dragIndex: dragIndex,
          ranges: compareRanges,
          validDropPositions: dropTarget === dragTarget ? validDropPositions : undefined
        }),
        newDropIndex = _getDropIndex.index,
        locked = _getDropIndex.locked;
      DRAG_INFO.newLocked = locked;
      if (newDropIndex != undefined) {
        dropIndex = newDropIndex;
      }
      var offset = 0;
      var visible;
      if (locked === 'start' && newDropIndex === this.props.firstUnlockedIndex) {
        offset = (rtl ? -1 : 1) * -11;
      }
      if (newDropIndex === this.props.firstLockedEndIndex && dragIndex !== this.props.firstLockedEndIndex) {
        if (locked === 'end') {
          offset = (rtl ? -1 : 1) * 4;
        } else if (!locked) {
          offset = (rtl ? -1 : 1) * -6;
        }
      }
      if (newDropIndex === this.props.visibleColumns.length) {
        offset = rtl ? 6 : -6;
      }
      if (locked == null && dragComputedLocked === 'end' && newDropIndex === this.props.firstLockedEndIndex) {
        visible = true;
      }
      this.dropIndex = dropIndex;
      this.setReorderArrowPosition(undefined, dropTarget);
      this.setReorderArrowAt(dropIndex, compareRanges, dropTarget, offset, visible);
    }
  }, {
    key: "setColumnOrder",
    value: function setColumnOrder(newColumnOrder) {
      var columnOrder = getColumnOrder(this.props);
      if (this.props.setColumnOrder && JSON.stringify(columnOrder) !== JSON.stringify(newColumnOrder)) {
        this.props.setColumnOrder(newColumnOrder);
      }
    }
  }, {
    key: "setGroupBy",
    value: function setGroupBy(groupBy) {
      if (this.props.onGroupByChange && JSON.stringify(groupBy) !== JSON.stringify(this.props.computedGroupBy)) {
        this.props.onGroupByChange(groupBy);
      }
    }
  }, {
    key: "insertGroupBy",
    value: function insertGroupBy(at, column) {
      var props = this.props;
      var order = (0, _toConsumableArray2.default)(props.computedGroupBy);
      order.splice(at, 0, column.id);
      this.setGroupBy(order);
    }
  }]);
  return InovuaDataGridHeaderLayout;
}(_reactClass.default);
exports.default = InovuaDataGridHeaderLayout;
InovuaDataGridHeaderLayout.propTypes = {
  i18n: _propTypes.default.func.isRequired,
  renderGroupToolbar: _propTypes.default.func,
  renderDragGroupItem: _propTypes.default.func,
  getScrollLeftMax: _propTypes.default.func.isRequired,
  setScrollLeft: _propTypes.default.func.isRequired,
  renderColumnReorderProxy: _propTypes.default.func,
  stickyHeader: _propTypes.default.bool
};