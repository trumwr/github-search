/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = function _default(_ref) {
  var dragTarget = _ref.dragTarget,
    dropTarget = _ref.dropTarget,
    dragMinIndex = _ref.dragMinIndex,
    dragMaxIndex = _ref.dragMaxIndex,
    dragRange = _ref.dragRange,
    ranges = _ref.ranges,
    rtl = _ref.rtl,
    dir = _ref.dir,
    validDropPositions = _ref.validDropPositions;
  ranges = ranges || [];
  var dragIndex = dragRange.index;
  var draggingLocked = dragRange.computedLocked;
  var locked = draggingLocked;
  var isValid = function isValid(i) {
    if (i === undefined) {
      return false;
    }
    var validDropIndex = dropTarget === 'group' || !validDropPositions || validDropPositions[i];
    if (dragMinIndex !== undefined && i < dragMinIndex || dragMaxIndex !== undefined && i > dragMaxIndex || !validDropIndex || i > ranges.length) {
      return false;
    }
    return true;
  };
  var searchInRanges = dragTarget != dropTarget ? ranges : dir == 1 ? ranges.slice(dragIndex) : ranges.slice(0, dragIndex);
  var currentRange;
  var halfSize;
  var thisDir;
  var index;
  var foundIndex;
  for (var i = 0, len = searchInRanges.length; i < len; i++) {
    currentRange = searchInRanges[i];
    if (!currentRange) {
      continue;
    }
    index = currentRange.index;
    thisDir = index <= dragIndex || dragTarget !== dropTarget ? -1 : 1;
    halfSize = (currentRange.right - currentRange.left) / 2;
    if (thisDir > 0) {
      if (isValid(index + 1) && (rtl ? dragRange.left <= currentRange.right - halfSize : dragRange.right >= currentRange.left + halfSize)) {
        foundIndex = index + 1;
      }
    } else {
      if (isValid(index) && (rtl ? dragRange.right > currentRange.right - halfSize : dragRange.left < currentRange.left + halfSize)) {
        foundIndex = index;
        if (dropTarget !== dragTarget || dir === -1) {
          break;
        }
      }
    }
  }
  if (dragTarget === dropTarget) {
    if (foundIndex === dragIndex + 1) {
      foundIndex++;
    } else if (foundIndex === undefined) {
      foundIndex = dragIndex === ranges.length - 1 || dragIndex === 0 ? dragIndex : dir > 1 ? ranges.length : undefined;
    }
  } else if (foundIndex === undefined) {
    foundIndex = ranges.length;
  }
  if (!isValid(foundIndex)) {
    foundIndex = undefined;
  }
  if (dragMinIndex !== undefined && foundIndex < dragMinIndex) {
    foundIndex = dragMinIndex;
  }
  if (dragMaxIndex !== undefined && foundIndex > dragMaxIndex) {
    foundIndex = dragMaxIndex;
  }
  if (!isValid(foundIndex)) {
    foundIndex = dragIndex;
  }
  if (!isValid(foundIndex)) {
    foundIndex = undefined;
  }
  if (isValid(foundIndex) && ranges[foundIndex]) {
    locked = ranges[foundIndex].computedLocked;
  }
  var initialLocked = locked;
  if (dir === 1) {
    var targetRange = ranges[foundIndex];
    var beforeTargetRange = ranges[foundIndex - 1];
    var afterTargetRange = ranges[foundIndex + 1];
    if (targetRange && !targetRange.computedLocked) {
      if (rtl) {
        if (dragRange.left < targetRange.right) {
          locked = targetRange.computedLocked;
        } else {
          locked = beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;
        }
      } else {
        if (dragRange.right > targetRange.left) {
          locked = targetRange.computedLocked;
        } else {
          locked = beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;
        }
      }
    } else if (targetRange && targetRange.computedLocked === 'end') {
      if (rtl) {
        locked = dragRange.left < targetRange.right ? 'end' : beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;
      } else {
        locked = dragRange.right > targetRange.left ? 'end' : beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;
      }
    } else if (afterTargetRange && !afterTargetRange.computedLocked && (rtl ? dragRange.left > afterTargetRange.right : dragRange.right > afterTargetRange.left)) {
      locked = null;
    } else if (beforeTargetRange && beforeTargetRange.computedLocked === 'end') {
      locked = 'end';
    }
  }
  if (dir === -1) {
    var _targetRange = ranges[foundIndex];
    var _beforeTargetRange = ranges[foundIndex - 1];
    if (_beforeTargetRange && !_beforeTargetRange.computedLocked && (rtl ? dragRange.right > _beforeTargetRange.left : dragRange.left < _beforeTargetRange.right)) {
      locked = null;
    } else if (_beforeTargetRange && _beforeTargetRange.computedLocked === 'start' && (rtl ? dragRange.right > _beforeTargetRange.left : dragRange.left < _beforeTargetRange.right)) {
      locked = 'start';
    } else if (_targetRange && _targetRange.computedLocked === 'end' && (rtl ? dragRange.right > _targetRange.left : dragRange.left < _targetRange.right)) {
      locked = 'end';
    }
  }
  if (draggingLocked === 'start' && ranges[foundIndex] && ranges[foundIndex].computedLocked === 'start' && locked == null) {
    foundIndex++;
  }
  return {
    index: foundIndex,
    locked: locked
  };
};
exports.default = _default;