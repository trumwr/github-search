/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cleanProps", {
  enumerable: true,
  get: function get() {
    return _reactCleanProps.default;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getScrollbarWidth", {
  enumerable: true,
  get: function get() {
    return _getScrollbarWidth.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function get() {
    return _isMobile.default;
  }
});
exports.propTypes = void 0;
Object.defineProperty(exports, "scrollPage", {
  enumerable: true,
  get: function get() {
    return _scrollPage2.default;
  }
});
Object.defineProperty(exports, "smoothScrollTo", {
  enumerable: true,
  get: function get() {
    return _smoothScrollTo2.default;
  }
});
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _debounce = _interopRequireDefault(require("../../../packages/debounce"));
var _autoBind = _interopRequireDefault(require("../../../packages/react-class/autoBind"));
var _reactCleanProps = _interopRequireDefault(require("../../../packages/react-clean-props"));
var _src = _interopRequireDefault(require("../../../packages/react-notify-resize/src"));
var _isMobile = _interopRequireDefault(require("../../../packages/isMobile"));
var _smoothScrollTo2 = _interopRequireDefault(require("../../../packages/smoothScrollTo"));
var _scrollPage2 = _interopRequireDefault(require("../../../packages/scrollPage"));
var _getScrollbarWidth = _interopRequireDefault(require("../../../packages/getScrollbarWidth"));
var _shouldComponentUpdate2 = _interopRequireDefault(require("../../../packages/shouldComponentUpdate"));
var _Scrollbar = _interopRequireDefault(require("./Scrollbar"));
var _getGlobal = require("../../../getGlobal");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var globalObject = (0, _getGlobal.getGlobal)();
var callFn = function callFn(fn) {
  return fn();
};
var raf = globalObject.requestAnimationFrame;
var ua = globalObject.navigator ? globalObject.navigator.userAgent || '' : '';
var IS_EDGE = ua.indexOf('Edge/') !== -1;
var IS_MS_BROWSER = IS_EDGE || ua.indexOf('Trident') !== -1;
var IS_IE = IS_MS_BROWSER && !IS_EDGE;
var HAS_NEGATIVE_SCROLL = false;
var WRAPPER_STYLE = {
  overflow: 'hidden',
  flex: '1 1 auto',
  position: 'relative',
  display: 'flex'
};
var VERTICAL = 'vertical';
var HORIZONTAL = 'horizontal';
var SIZES = {
  vertical: 'height',
  horizontal: 'width'
};
var OTHER_ORIENTATION = {
  vertical: 'horizontal',
  horizontal: 'vertical'
};
var InovuaScrollContainer = function (_Component) {
  (0, _inherits2.default)(InovuaScrollContainer, _Component);
  var _super = _createSuper(InovuaScrollContainer);
  function InovuaScrollContainer(props) {
    var _this;
    (0, _classCallCheck2.default)(this, InovuaScrollContainer);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scrollerScrollSize", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scrollerClientSize", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "refScroller", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scrollerNode", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "computeScrollWithThreshold", function (scrollTop, scrollThreshold, scrollMaxDelta) {
      var scrollPercent = function scrollPercent(threshold) {
        threshold = threshold < 0.4 ? 0.4 : threshold;
        threshold = threshold > 1 ? 1 : threshold;
        var scrollMax = scrollMaxDelta ? _this.scrollTopMax - scrollMaxDelta : _this.scrollTopMax;
        var percent = scrollTop / scrollMax;
        if (percent >= threshold) {
          return true;
        }
        return false;
      };
      if (typeof scrollThreshold === 'number') {
        return scrollPercent(scrollThreshold);
      }
      if (typeof scrollThreshold === 'string') {
        if (scrollThreshold.match(/^(\d*(\.\d+)?)%$/)) {
          var threshold = parseFloat(scrollThreshold) / 100;
          return scrollPercent(threshold);
        }
        if (scrollThreshold.match(/^(\d*(\.\d+)?)px$/)) {
          var scrollMax = scrollMaxDelta ? _this.scrollTopMax - scrollMaxDelta : _this.scrollTopMax;
          var _threshold = parseFloat(scrollThreshold);
          if (scrollTop >= scrollMax - _threshold) {
            return true;
          }
        }
      }
      return false;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "applyCSSContainOnScrollUpdate", function (bool) {
      var scrollerNode = _this.getScrollerNode();
      if (scrollerNode) {
        scrollerNode.style.contain = bool ? 'strict' : '';
      }
    });
    (0, _autoBind.default)((0, _assertThisInitialized2.default)(_this), {
      scrollTop: 1,
      scrollLeft: 1,
      scrollTopMax: 1,
      scrollLeftMax: 1
    });
    _this.state = {
      scrollbars: {
        horizontal: false,
        vertical: false
      }
    };
    _this.scrollerResizerRef = function (s) {
      _this._scrollerResizer = s;
    };
    if (props.scrollDebounceDelay > 0) {
      _this.onScrollDebounce = (0, _debounce.default)(_this.onScrollDebounce, props.scrollDebounceDelay, {
        leading: false
      });
    }
    _this.onStop = (0, _debounce.default)(_this.onStop, props.scrollStopDelay, {
      leading: false
    });
    _this.nativeScrollbarWidth = (0, _getScrollbarWidth.default)(_this.props.hideNativeScrollbarIfPossible);
    _this.scroll = {
      scrollTop: 0,
      scrollLeft: 0
    };
    _this.trackSize = {};
    _this.clientSize = {};
    _this.scrollSize = {};
    _this.scrollbars = {};
    _this.scrollerClientSize = {};
    _this.scrollerScrollSize = {};
    _this.scrollbarRef = {
      vertical: function vertical(c) {
        _this.scrollbars.vertical = c;
      },
      horizontal: function horizontal(c) {
        var wasDefined = !!_this.scrollbars.horizontal;
        _this.scrollbars.horizontal = c;
        if (!wasDefined && c && _this.props.rtl) {
          c.setScrollPos(_this.scrollLeftMax);
        }
      }
    };
    _this.refThis = function (c) {
      _this.domNode = c;
    };
    _this.refWrapper = function (c) {
      if (c) {
        _this.setupWrapperPassiveScrollListener(c);
      } else {
        _this.removeWrapperPassiveScrollListener(_this.wrapperNode);
      }
      _this.wrapperNode = c;
    };
    _this.refView = function (v) {
      _this.viewNode = v;
    };
    _this.refScroller = (0, _react.createRef)();
    return _this;
  }
  (0, _createClass2.default)(InovuaScrollContainer, [{
    key: "onWrapperScroll",
    value: function onWrapperScroll(event) {
      var _this2 = this;
      var eventTarget = event.target;
      if (eventTarget != this.wrapperNode) {
        return;
      }
      var scrollLeft = eventTarget.scrollLeft,
        scrollTop = eventTarget.scrollTop;
      if (scrollLeft) {
        eventTarget.scrollLeft = 0;
        raf(function () {
          _this2.scrollLeft += scrollLeft;
        });
      }
      if (scrollTop) {
        eventTarget.scrollTop = 0;
        raf(function () {
          _this2.scrollTop += scrollTop;
        });
      }
    }
  }, {
    key: "setupWrapperPassiveScrollListener",
    value: function setupWrapperPassiveScrollListener(node) {
      node.addEventListener('scroll', this.onWrapperScroll, {
        passive: true
      });
    }
  }, {
    key: "removeWrapperPassiveScrollListener",
    value: function removeWrapperPassiveScrollListener() {
      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.wrapperNode;
      if (node) {
        node.removeEventListener('scroll', this.onWrapperScroll, {
          passive: true
        });
      }
    }
  }, {
    key: "setupPassiveScrollListener",
    value: function setupPassiveScrollListener(node) {
      node.addEventListener('scroll', this.onScroll, {
        passive: true
      });
    }
  }, {
    key: "removePassiveScrollListener",
    value: function removePassiveScrollListener() {
      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getScrollerNode();
      if (node) {
        node.removeEventListener('scroll', this.onScroll, {
          passive: true
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unmounted = true;
      if (this.props.usePassiveScroll) {
        this.removePassiveScrollListener();
      }
      if (typeof this.props.onWillUnmount === 'function') {
        this.props.onWillUnmount(this);
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.unmounted = false;
      this.scrollerNode = this.refScroller.current;
      var scrollerNode = this.getScrollerNode();
      if (this.props.usePassiveScroll) {
        if (scrollerNode) {
          this.setupPassiveScrollListener(scrollerNode);
        } else {
          this.removePassiveScrollListener(scrollerNode);
        }
      }
      if (typeof this.props.onDidMount === 'function') {
        this.props.onDidMount(this, this.getDOMNode(), this._scrollerResizer);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return (0, _shouldComponentUpdate2.default)(this, nextProps, nextState);
    }
  }, {
    key: "ensureNonStaticStyle",
    value: function ensureNonStaticStyle(style, domNode) {
      if (!this.props.forceNonStaticPosition) {
        return style;
      }
      style = style || {};
      var _style = style,
        position = _style.position;
      var nonStatic = position == 'relative' || position == 'absolute';
      if (nonStatic) {
        return style;
      }
      if (domNode) {
        position = globalObject.getComputedStyle(domNode).position;
        nonStatic = position == 'relative' || position == 'absolute';
        if (!nonStatic) {
          return _objectSpread(_objectSpread({}, style), {}, {
            position: 'relative'
          });
        }
      }
      return _objectSpread(_objectSpread({}, style), {}, {
        position: 'relative'
      });
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;
      var renderScroller = props.renderScroller,
        renderView = props.renderView,
        Factory = props.factory,
        inlineBlock = props.inlineBlock,
        usePassiveScroll = props.usePassiveScroll,
        theme = props.theme,
        contain = props.contain,
        nativeScroll = props.nativeScroll;
      var style = props.style,
        children = props.children;
      var className = props.className || '';
      style = _objectSpread({
        overflow: 'hidden',
        display: props.display ? props.display : inlineBlock ? 'inline-flex' : 'flex',
        flexFlow: 'column'
      }, this.ensureNonStaticStyle(style, this.domNode));
      if (contain) {
        if (contain === true) {
          style.contain = 'style layout paint';
        } else {
          style.contain = contain;
        }
      }
      var factoryProps = (0, _reactCleanProps.default)(props, InovuaScrollContainer.propTypes);
      className += inlineBlock ? ' inovua-react-scroll-container--inline-block' : ' inovua-react-scroll-container--block';
      className += ' inovua-react-scroll-container';
      if (theme) {
        className += " inovua-react-scroll-container--theme-".concat(theme);
      }
      var nativeScrollbarWidth = this.nativeScrollbarWidth;
      var emptyScrollOffset = this.getEmptyScrollOffset();
      var scrollerStyle = {};
      if (this.props.inertialScroll) {
        scrollerStyle.WebkitOverflowScrolling = 'touch';
      }
      if (this.props.scrollerStyle) {
        scrollerStyle = _objectSpread(_objectSpread({}, scrollerStyle), this.props.scrollerStyle);
      }
      scrollerStyle.overflow = nativeScroll ? 'auto' : 'scroll';
      scrollerStyle.direction = this.props.rtl ? 'rtl' : 'ltr';
      if (!nativeScroll) {
        scrollerStyle[this.props.rtl ? 'marginLeft' : 'marginRight'] = -emptyScrollOffset - nativeScrollbarWidth;
        scrollerStyle.marginBottom = -emptyScrollOffset - nativeScrollbarWidth;
      }
      var viewClassName = "".concat(this.props.viewClassName || '', " inovua-react-scroll-container__view ").concat(!nativeScrollbarWidth ? 'inovua-react-scroll-container__view--zero-width-scrollbar' : '');
      var viewChildren = children;
      var viewStyle = {};
      if (this.props.viewStyle) {
        viewStyle = _objectSpread(_objectSpread({}, viewStyle), this.props.viewStyle);
      }
      if (!emptyScrollOffset || nativeScroll) {
        viewChildren = children;
      } else {
        viewStyle[this.props.rtl ? 'paddingLeft' : 'paddingRight'] = emptyScrollOffset;
        var viewChildrenStyle = {
          paddingBottom: emptyScrollOffset
        };
        if (IS_IE) {
          viewChildrenStyle.display = 'inline-block';
        }
        viewChildren = _react.default.createElement("div", {
          key: "viewChildren",
          style: viewChildrenStyle
        }, children);
      }
      var resizer = !!this.props.resizer;
      var viewProps = {
        ref: this.refView,
        className: viewClassName,
        style: viewStyle,
        children: [viewChildren, resizer && _react.default.createElement(_src.default, {
          ResizeObserver: this.props.ResizeObserver,
          checkResizeDelay: this.props.checkResizeDelay,
          key: "viewResizer",
          useRaf: this.props.rafOnResize,
          onResize: this.onViewResize,
          notifyOnMount: true
        })]
      };
      var view = renderView ? renderView(viewProps) : _react.default.createElement("div", _objectSpread({
        key: "view"
      }, viewProps));
      var scrollerProps = {
        className: "inovua-react-scroll-container__scroller inovua-react-scroll-container__scroller--direction-".concat(this.props.rtl ? 'rtl' : 'ltr'),
        style: scrollerStyle,
        ref: this.refScroller,
        children: [view, resizer ? _react.default.createElement(_src.default, _objectSpread(_objectSpread({
          ref: this.scrollerResizerRef
        }, props.scrollerResizerProps), {}, {
          ResizeObserver: this.props.ResizeObserver,
          checkResizeDelay: this.props.checkResizeDelay,
          useRaf: this.props.rafOnResize,
          key: "scrollerResizer",
          onResize: this.onResize,
          notifyOnMount: true
        })) : null].filter(Boolean)
      };
      if (!usePassiveScroll) {
        scrollerProps.onScroll = this.onScroll;
      }
      if (this.props.avoidRepaintOnScroll) {
        scrollerProps.className += ' inovua-react-scroll-container__scroller--avoid-repaint';
      }
      if (this.props.hideNativeScrollbarIfPossible) {
        scrollerProps.className += ' inovua-react-scroll-container__scroller--hide-native-scrollbar-if-possible';
      }
      if (this.props.dragToScroll) {
        scrollerProps.tabIndex = -1;
      }
      var scroller = renderScroller ? renderScroller(scrollerProps) : _react.default.createElement("div", _objectSpread({}, scrollerProps));
      children = [_react.default.createElement("div", {
        key: "wrapper",
        className: "inovua-react-scroll-container__wrapper",
        ref: this.refWrapper,
        style: this.props.wrapperStyle ? _objectSpread(_objectSpread({}, WRAPPER_STYLE), this.props.wrapperStyle) : WRAPPER_STYLE,
        children: scroller
      })].concat((0, _toConsumableArray2.default)(this.renderScrollbars()), [this.props.before ? _react.default.cloneElement(this.props.before, {
        key: 'before'
      }) : null, this.props.after ? _react.default.cloneElement(this.props.after, {
        key: 'after',
        style: _objectSpread(_objectSpread({}, this.props.after.props.style), {}, {
          bottom: this.state.scrollbars.horizontal && this.props.nativeScroll ? this.nativeScrollbarWidth : 0
        })
      }) : null]);
      if (this.props.showScrollbarsOnOver) {
        factoryProps.onMouseEnter = this.onMouseEnter;
        factoryProps.onMouseLeave = this.onMouseLeave;
      }
      return Factory ? _react.default.createElement(Factory, _objectSpread(_objectSpread({}, factoryProps), {}, {
        ref: this.refThis,
        style: style,
        className: className,
        children: children
      })) : (0, _react.createElement)(props.tagName, _objectSpread(_objectSpread({}, factoryProps), {}, {
        ref: this.refThis,
        style: style,
        className: className,
        children: children
      }));
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(event) {
      this.mouseEntered = true;
      this.setScrollbarsVisible({
        horizontal: true,
        vertical: true
      });
      if (this.props.onMouseEnter) {
        this.props.onMouseEnter(event);
      }
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave() {
      this.mouseEntered = false;
      this.setScrollbarsVisible({
        horizontal: false,
        vertical: false
      });
      if (this.props.onMouseLeave) {
        this.props.onMouseLeave(event);
      }
    }
  }, {
    key: "onViewResize",
    value: function onViewResize(size) {
      var _this3 = this;
      this.rafSync(function () {
        if (_this3.props.onViewResize) {
          _this3.props.onViewResize(size, _this3);
        }
      });
    }
  }, {
    key: "onResize",
    value: function onResize(size) {
      var _this4 = this;
      if (this.props.rafOnResize) {
        this.rafSync(function () {
          if (_this4.props.onResize) {
            _this4.props.onResize(size, _this4);
          }
        });
      } else {
        this.sync();
        if (this.props.onResize) {
          this.props.onResize(size, this);
        }
      }
    }
  }, {
    key: "getDOMNode",
    value: function getDOMNode() {
      return this.domNode;
    }
  }, {
    key: "scrollTop",
    get: function get() {
      return this.scroll.scrollTop;
    },
    set: function set(value) {
      this.getScrollerNode().scrollTop = value;
    }
  }, {
    key: "scrollLeft",
    get: function get() {
      return this.scroll.scrollLeft;
    },
    set: function set(value) {
      this.getScrollerNode().scrollLeft = value;
    }
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return this.scroll;
    }
  }, {
    key: "scrollTopMax",
    get: function get() {
      if (!this.scrollerScrollSize.height || !this.scrollerClientSize.height) {
        this.getScrollbars();
      }
      return this.scrollerScrollSize.height - this.scrollerClientSize.height;
    }
  }, {
    key: "scrollLeftMax",
    get: function get() {
      if (!this.scrollerScrollSize.width || !this.scrollerClientSize.width) {
        this.getScrollbars();
      }
      return this.scrollerScrollSize.width - this.scrollerClientSize.width;
    }
  }, {
    key: "renderScrollbars",
    value: function renderScrollbars() {
      var scrollbars = this.state.scrollbars;
      return [scrollbars.vertical && this.renderScrollbar('vertical', scrollbars), scrollbars.horizontal && this.renderScrollbar('horizontal', scrollbars)];
    }
  }, {
    key: "getEmptyScrollOffset",
    value: function getEmptyScrollOffset() {
      return this.props.emptyScrollOffset == null ? _isMobile.default ? 17 : IS_IE ? 0 : (0, _getScrollbarWidth.default)() : this.props.emptyScrollOffset;
    }
  }, {
    key: "renderScrollbar",
    value: function renderScrollbar(orientation, scrollbars) {
      if (this.checkAllowedScrollbars()[orientation] === false) {
        return null;
      }
      var sizeName = SIZES[orientation];
      var nativeScrollbarWidth = this.nativeScrollbarWidth;
      var oppositeVisible = scrollbars[OTHER_ORIENTATION[orientation]];
      var _this$props = this.props,
        scrollThumbWidth = _this$props.scrollThumbWidth,
        scrollThumbStartEndRespectMargin = _this$props.scrollThumbStartEndRespectMargin,
        scrollThumbMargin = _this$props.scrollThumbMargin;
      var trackSize = this.trackSize[sizeName];
      trackSize -= scrollThumbMargin * (scrollThumbStartEndRespectMargin ? 2 : 1);
      if (oppositeVisible) {
        trackSize -= scrollThumbWidth;
      }
      var emptyScrollOffset = this.getEmptyScrollOffset();
      var scrollbarProps = {
        key: orientation,
        ref: this.scrollbarRef[orientation],
        emptyScrollOffset: emptyScrollOffset,
        nativeScrollbarWidth: nativeScrollbarWidth,
        orientation: orientation,
        visible: !this.props.autoHide,
        autoHide: this.props.autoHide,
        rtl: this.props.rtl,
        oppositeVisible: oppositeVisible,
        scrollThumbStyle: this.props.scrollThumbStyle,
        trackSize: trackSize,
        scrollSize: this.scrollerScrollSize[sizeName],
        clientSize: this.clientSize[sizeName] + emptyScrollOffset,
        dragToScroll: this.props.dragToScroll,
        scrollThumbMinSize: this.props.scrollThumbMinSize,
        scrollThumbRadius: this.props.scrollThumbRadius,
        scrollThumbStartEndRespectMargin: scrollThumbStartEndRespectMargin,
        scrollThumbOverWidth: this.props.scrollThumbOverWidth,
        scrollThumbWidth: scrollThumbWidth,
        scrollThumbMargin: scrollThumbMargin,
        scrollTrackOverTransitionDuration: this.props.scrollTrackOverTransitionDuration,
        showTrackOnDrag: this.props.showTrackOnDrag,
        alwaysShowTrack: this.props.alwaysShowTrack,
        hideTransitionDuration: this.props.hideTransitionDuration,
        showTransitionDuration: this.props.showTransitionDuration,
        onScrollThumbScrollTop: this.onScrollThumbScrollTop,
        onScrollThumbScrollLeft: this.onScrollThumbScrollLeft,
        onStartDrag: this.props.dragToScroll && this.onScrollbarStartDrag,
        onStopDrag: this.props.dragToScroll && this.onScrollbarStopDrag,
        onWheelScroll: this.onScrollbarWheelScroll,
        onPageScroll: this.onScrollbarPageScroll
      };
      return _react.default.createElement(_Scrollbar.default, _objectSpread({}, scrollbarProps));
    }
  }, {
    key: "onScrollbarStartDrag",
    value: function onScrollbarStartDrag(orientation) {
      if (this.props.onScrollbarStartDrag) {
        this.props.onScrollbarStartDrag(orientation);
      }
      if (orientation == VERTICAL && this.props.onVerticalScrollbarStartDrag) {
        this.props.onVerticalScrollbarStartDrag();
      } else if (this.props.onHorizontalScrollbarStartDrag) {
        this.props.onHorizontalScrollbarStartDrag();
      }
    }
  }, {
    key: "onScrollbarStopDrag",
    value: function onScrollbarStopDrag(orientation) {
      this.focus();
      if (this.props.onScrollbarStopDrag) {
        this.props.onScrollbarStopDrag(orientation);
      }
      if (orientation == VERTICAL && this.props.onVerticalScrollbarStopDrag) {
        this.props.onVerticalScrollbarStopDrag();
      } else if (this.props.onHorizontalScrollbarStopDrag) {
        this.props.onHorizontalScrollbarStopDrag();
      }
    }
  }, {
    key: "focus",
    value: function focus() {
      this.getScrollerNode().focus();
    }
  }, {
    key: "onScrollbarWheelScroll",
    value: function onScrollbarWheelScroll(orientation, delta) {
      var node = this.getScrollerNode();
      var horiz = orientation == 'horizontal';
      var scrollPosName = horiz ? 'scrollLeft' : 'scrollTop';
      var currentValue = node[scrollPosName];
      var newValue = currentValue + delta;
      this.smoothScrollTo(newValue, {
        orientation: orientation,
        duration: 10
      });
    }
  }, {
    key: "onScrollbarPageScroll",
    value: function onScrollbarPageScroll(orientation, direction) {
      this.focus();
      this.scrollPage(orientation, direction);
    }
  }, {
    key: "scrollPage",
    value: function scrollPage(orientation, direction) {
      if (!direction) {
        throw new Error('Please provide a scroll direction: 1 or -1!');
      }
      var node = this.getScrollerNode();
      var horiz = orientation == 'horizontal';
      (0, _scrollPage2.default)(node, {
        orientation: orientation,
        direction: direction,
        pageSize: this.clientSize[horiz ? 'width' : 'height'] - 20
      });
    }
  }, {
    key: "scrollHorizontalPage",
    value: function scrollHorizontalPage(direction) {
      this.scrollPage('horizontal', direction);
    }
  }, {
    key: "scrollVerticalPage",
    value: function scrollVerticalPage(direction) {
      this.scrollPage('vertical', direction);
    }
  }, {
    key: "smoothScrollTo",
    value: function smoothScrollTo(newValue, cfg, callback) {
      return (0, _smoothScrollTo2.default)(this.getScrollerNode(), newValue, cfg, callback);
    }
  }, {
    key: "onScrollThumbScrollTop",
    value: function onScrollThumbScrollTop(pos) {
      this.getScrollerNode().scrollTop = pos;
    }
  }, {
    key: "onScrollThumbScrollLeft",
    value: function onScrollThumbScrollLeft(pos) {
      this.getScrollerNode().scrollLeft = pos;
    }
  }, {
    key: "getScrollerNode",
    value: function getScrollerNode() {
      this.scrollerNode = this.scrollerNode || this.refScroller.current || this.getDOMNode().firstChild.firstChild;
      return this.scrollerNode;
    }
  }, {
    key: "getScrollerChild",
    value: function getScrollerChild() {
      this.scrollerChild = this.scrollerChild || this.getScrollerNode().firstChild;
      return this.scrollerChild;
    }
  }, {
    key: "getTrackSize",
    value: function getTrackSize() {
      var node = this.getDOMNode();
      if (this.props.getTrackSize) {
        return this.props.getTrackSize(node);
      }
      return {
        width: node.clientWidth,
        height: node.clientHeight
      };
    }
  }, {
    key: "getScrollSize",
    value: function getScrollSize() {
      if (this.props.getScrollSize) {
        return this.props.getScrollSize(this.getScrollerNode());
      }
      var node = this.getScrollerChild();
      return {
        width: node.scrollWidth,
        height: node.scrollHeight
      };
    }
  }, {
    key: "getClientSize",
    value: function getClientSize() {
      var n = this.getDOMNode();
      if (this.props.getClientSize) {
        return this.props.getClientSize(n);
      }
      var node = n.firstChild;
      return {
        width: node.clientWidth,
        height: node.clientHeight
      };
    }
  }, {
    key: "getScrollbars",
    value: function getScrollbars() {
      this.trackSize = this.getTrackSize();
      var scrollSize = this.scrollSize = this.getScrollSize();
      this.clientSize = this.getClientSize();
      var scrollerNode = this.getScrollerNode();
      this.scrollerClientSize = this.props.getScrollerNodeClientSize ? this.props.getScrollerNodeClientSize(scrollerNode) : {
        height: scrollerNode.clientHeight,
        width: scrollerNode.clientWidth
      };
      var scrollerNodeClientSize = this.scrollerClientSize;
      this.scrollerScrollSize = {
        height: scrollerNode.scrollHeight,
        width: scrollerNode.scrollWidth
      };
      if (this.props.rtl) {}
      var scrollbars = {
        vertical: scrollSize.height > scrollerNodeClientSize.height,
        horizontal: scrollSize.width > scrollerNodeClientSize.width
      };
      return scrollbars;
    }
  }, {
    key: "rafSync",
    value: function rafSync(callback) {
      var _this5 = this;
      raf(function () {
        _this5.sync();
        if (callback) {
          callback();
        }
      });
    }
  }, {
    key: "sync",
    value: function sync() {
      var _this6 = this;
      if (this.unmounted) {
        return;
      }
      var oldScrollbars = this.state.scrollbars;
      var scrollbars = this.getScrollbars();
      this.setState({
        scrollbars: scrollbars
      }, function () {
        if (_this6.props.onScrollbarsChange && (scrollbars.vertical != oldScrollbars.vertical || scrollbars.horizontal != oldScrollbars.horizontal)) {
          _this6.props.onScrollbarsChange(scrollbars);
        }
      });
      if (this.props.rtl) {
        var scrollNode = this.getScrollerNode();
        if (!scrollNode) {
          return;
        }
        this.onScrollDebounce(scrollNode);
      }
    }
  }, {
    key: "hasScrollbar",
    value: function hasScrollbar(orientation) {
      return this.state.scrollbars[orientation];
    }
  }, {
    key: "hasVerticalScrollbar",
    value: function hasVerticalScrollbar() {
      return this.hasScrollbar(VERTICAL);
    }
  }, {
    key: "hasHorizontalScrollbar",
    value: function hasHorizontalScrollbar() {
      return this.hasScrollbar(HORIZONTAL);
    }
  }, {
    key: "onScroll",
    value: function onScroll(event) {
      var eventTarget = event.target;
      if (this.props.onScroll) {
        this.props.onScroll(event);
      }
      var scrollerNode = this.getScrollerNode();
      if (eventTarget != scrollerNode) {
        return;
      }
      this.onScrollDebounce(eventTarget);
    }
  }, {
    key: "onScrollDebounce",
    value: function onScrollDebounce(eventTarget) {
      var _this7 = this;
      var props = this.props;
      var rafOnScroll = props.rafOnScroll,
        cancelPrevScrollRaf = props.cancelPrevScrollRaf,
        avoidScrollTopBrowserLayout = props.avoidScrollTopBrowserLayout,
        scrollMaxDelta = props.scrollMaxDelta,
        scrollThreshold = props.scrollThreshold;
      var rafFn = rafOnScroll ? raf : callFn;
      if (this.scrollRafId && rafOnScroll && cancelPrevScrollRaf) {
        globalObject.cancelAnimationFrame(this.scrollRafId);
      }
      this.scrollRafId = rafFn(function () {
        if (_this7.unmounted) {
          return;
        }
        delete _this7.scrollRafId;
        var onScrollStart = props.onScrollStart,
          onScrollStop = props.onScrollStop,
          autoHide = props.autoHide,
          applyCSSContainOnScroll = props.applyCSSContainOnScroll;
        var startStop = !!(onScrollStart || onScrollStop || autoHide || avoidScrollTopBrowserLayout || applyCSSContainOnScroll);
        var scrollTop;
        var scrollLeft;
        if (!avoidScrollTopBrowserLayout) {
          scrollTop = eventTarget.scrollTop;
          scrollLeft = eventTarget.scrollLeft;
        } else {
          var targetRect = _this7.targetRect || eventTarget.getBoundingClientRect();
          _this7.targetRect = targetRect;
          var viewRect = eventTarget.firstChild.getBoundingClientRect();
          scrollTop = targetRect.top - viewRect.top;
          scrollLeft = targetRect.left - viewRect.left;
        }
        var scrollLeftMax = _this7.scrollerScrollSize.width - _this7.scrollerClientSize.width;
        var scrollPos = {
          scrollTop: scrollTop,
          scrollLeft: scrollLeft,
          scrollLeftMax: scrollLeftMax
        };
        var prevScrollPos = _this7.scroll;
        var prevScrollTop = prevScrollPos.scrollTop,
          prevScrollLeft = prevScrollPos.scrollLeft,
          prevScrollLeftMax = prevScrollPos.scrollLeftMax;
        if (startStop) {
          if (!_this7.scrollStarted) {
            if (applyCSSContainOnScroll) {
              _this7.applyCSSContainOnScrollUpdate(true);
            }
            if (onScrollStart) {
              onScrollStart(scrollPos, prevScrollPos, eventTarget);
            }
          }
        }
        var scrollVertical = false;
        var scrollHorizontal = false;
        if (props.onContainerScroll) {
          props.onContainerScroll(scrollPos, prevScrollPos, eventTarget, {
            scrollerScrollSize: _this7.scrollerScrollSize,
            scrollerClientSize: _this7.scrollerClientSize,
            scrollLeftMax: scrollLeftMax
          });
        }
        var scrollTopChange = scrollTop != prevScrollTop;
        if (scrollTopChange) {
          scrollVertical = true;
          if (_this7.scrollbars.vertical) {
            _this7.scrollbars.vertical.setScrollPos(scrollTop);
          }
          if (props.onContainerScrollVertical) {
            props.onContainerScrollVertical(scrollTop, prevScrollTop, eventTarget);
          }
          if (props.onContainerScrollVerticalMin && scrollTop == 0) {
            props.onContainerScrollVerticalMin(0, eventTarget);
          }
          if (props.onContainerScrollVerticalMax) {
            if (scrollThreshold) {
              var reachScrollMax = _this7.computeScrollWithThreshold(scrollTop, scrollThreshold, scrollMaxDelta);
              if (reachScrollMax) {
                props.onContainerScrollVerticalMax(scrollTop);
              }
            } else if (scrollMaxDelta ? scrollTop >= _this7.scrollTopMax - scrollMaxDelta : scrollTop == _this7.scrollTopMax) {
              props.onContainerScrollVerticalMax(scrollTop);
            }
          }
        }
        var scrollLeftChange = scrollLeft != prevScrollLeft;
        if (_this7.props.rtl && !scrollLeftChange) {
          scrollLeftChange = scrollLeftMax != prevScrollLeftMax;
        }
        if (scrollLeftChange) {
          scrollHorizontal = true;
          if (_this7.scrollbars.horizontal) {
            _this7.scrollbars.horizontal.setScrollPos(scrollLeft);
          }
          if (props.onContainerScrollHorizontal) {
            props.onContainerScrollHorizontal(scrollLeft, prevScrollLeft, eventTarget, scrollLeftMax);
          }
          if (props.onContainerScrollHorizontalMin && scrollLeft == 0) {
            props.onContainerScrollHorizontalMin(0, eventTarget);
          }
          if (props.onContainerScrollHorizontalMax && (scrollMaxDelta ? Math.abs(scrollLeft) >= scrollLeftMax - scrollMaxDelta : Math.abs(scrollLeft) == scrollLeftMax)) {
            props.onContainerScrollHorizontalMax(scrollLeft, eventTarget);
          }
        }
        if (startStop && (scrollTopChange || scrollLeftChange)) {
          if (!_this7.scrollStarted || _this7.scrollStarted.vertical != scrollVertical || _this7.scrollStarted.horizontal != scrollHorizontal) {
            _this7.lazyShowScrollbars();
            _this7.scrollStarted = {
              horizontal: scrollHorizontal,
              vertical: scrollVertical
            };
          }
          _this7.onStop(scrollPos, prevScrollPos, eventTarget);
        }
        _this7.scroll = scrollPos;
      });
    }
  }, {
    key: "getContainerTargetNode",
    value: function getContainerTargetNode() {
      var view = this.viewNode;
      return !this.props.emptyScrollOffset ? view : view.firstChild;
    }
  }, {
    key: "lazyShowScrollbars",
    value: function lazyShowScrollbars() {
      if (this.props.autoHide) {
        setTimeout(this.showScrollbars, this.props.showDelay);
      }
    }
  }, {
    key: "onStop",
    value: function onStop(scrollPos, prevScrollPos, eventTarget) {
      this.scrollStarted = false;
      if (this.props.applyCSSContainOnScroll) {
        this.applyCSSContainOnScrollUpdate(false);
      }
      delete this.targetRect;
      if (this.props.onScrollStop) {
        this.props.onScrollStop(scrollPos, prevScrollPos, eventTarget);
      }
      setTimeout(this.hideScrollbars, this.props.hideDelay);
    }
  }, {
    key: "showScrollbars",
    value: function showScrollbars() {
      if (this.props.autoHide && this.scrollStarted) {
        var _this$scrollbars = this.scrollbars,
          horizontal = _this$scrollbars.horizontal,
          vertical = _this$scrollbars.vertical;
        var _this$scrollStarted = this.scrollStarted,
          scrollHorizontal = _this$scrollStarted.horizontal,
          scrollVertical = _this$scrollStarted.vertical;
        var visibleScrollbars = {};
        if (scrollHorizontal) {
          visibleScrollbars.horizontal = true;
        }
        if (scrollVertical) {
          visibleScrollbars.vertical = true;
        }
        this.setScrollbarsVisible(visibleScrollbars);
      }
    }
  }, {
    key: "checkAllowedScrollbars",
    value: function checkAllowedScrollbars() {
      var result = {
        vertical: true,
        horizontal: true
      };
      var scrollbars = this.props.scrollbars;
      if (scrollbars === false) {
        result.vertical = false;
        result.horizontal = false;
      }
      if ((0, _typeof2.default)(scrollbars) == 'object') {
        if (scrollbars.horizontal === false) {
          result.horizontal = false;
        }
        if (scrollbars.false === false) {
          result.false = false;
        }
      }
      var _this$props2 = this.props,
        shouldAllowScrollbars = _this$props2.shouldAllowScrollbars,
        showScrollbars = _this$props2.showScrollbars;
      if (typeof shouldAllowScrollbars == 'function') {
        var shouldAllow = showScrollbars || shouldAllowScrollbars(this.props, (0, _getScrollbarWidth.default)());
        if (shouldAllow === false || shouldAllow && shouldAllow.horizontal === false) {
          result.horizontal = false;
        }
        if (shouldAllow === false || shouldAllow && shouldAllow.vertical === false) {
          result.vertical = false;
        }
      }
      return result;
    }
  }, {
    key: "setScrollbarsVisible",
    value: function setScrollbarsVisible(scrollbars) {
      var horizontalVisible = scrollbars.horizontal,
        verticalVisible = scrollbars.vertical;
      var _this$scrollbars2 = this.scrollbars,
        horizontal = _this$scrollbars2.horizontal,
        vertical = _this$scrollbars2.vertical;
      if (horizontalVisible !== undefined && horizontal) {
        horizontal.setVisible(horizontalVisible);
      }
      if (verticalVisible !== undefined && vertical) {
        vertical.setVisible(verticalVisible);
      }
    }
  }, {
    key: "hideScrollbars",
    value: function hideScrollbars() {
      if (this.props.showScrollbarsOnOver && this.mouseEntered) {
        return;
      }
      if (this.props.autoHide && !this.scrollStarted) {
        this.setScrollbarsVisible({
          horizontal: false,
          vertical: false
        });
      }
    }
  }]);
  return InovuaScrollContainer;
}(_react.Component);
exports.default = InovuaScrollContainer;
InovuaScrollContainer.defaultProps = {
  shouldAllowScrollbars: function shouldAllowScrollbars(props, scrollbarWidth) {
    if (props.nativeScroll) {
      return false;
    }
    if (!scrollbarWidth) {
      return false;
    }
  },
  avoidRepaintOnScroll: true,
  avoidScrollTopBrowserLayout: false,
  applyCSSContainOnScroll: true,
  alwaysShowTrack: false,
  autoHide: true,
  cancelPrevScrollRaf: true,
  contain: false,
  dragToScroll: true,
  forceNonStaticPosition: false,
  hideDelay: 400,
  hideTransitionDuration: '300ms',
  inertialScroll: true,
  inlineBlock: false,
  rafOnScroll: false,
  rafOnResize: false,
  scrollDebounceDelay: 0,
  resizer: true,
  rtl: false,
  scrollStopDelay: 180,
  scrollThumbMargin: 2,
  scrollThumbStartEndRespectMargin: true,
  scrollThumbWidth: 7,
  scrollThumbOverWidth: 10,
  scrollThumbRadius: 3,
  showDelay: 100,
  showScrollbarsOnOver: true,
  showTransitionDuration: '100ms',
  showTrackOnDrag: false,
  scrollTrackOverTransitionDuration: '100ms',
  usePassiveScroll: true,
  tagName: 'div',
  theme: 'default-light'
};
var propTypes = {
  alwaysShowTrack: _propTypes.default.bool,
  avoidScrollTopBrowserLayout: _propTypes.default.bool,
  applyCSSContainOnScroll: _propTypes.default.bool,
  avoidRepaintOnScroll: _propTypes.default.bool,
  autoHide: _propTypes.default.bool,
  cancelPrevScrollRaf: _propTypes.default.bool,
  dragToScroll: _propTypes.default.bool,
  display: _propTypes.default.string,
  checkResizeDelay: _propTypes.default.number,
  emptyScrollOffset: _propTypes.default.number,
  factory: _propTypes.default.func,
  nativeScroll: _propTypes.default.bool,
  forceNonStaticPosition: _propTypes.default.bool,
  hideDelay: _propTypes.default.number,
  getClientSize: _propTypes.default.func,
  getScrollSize: _propTypes.default.func,
  getTrackSize: _propTypes.default.func,
  getScrollerNodeClientSize: _propTypes.default.func,
  hideTransitionDuration: _propTypes.default.string,
  hideNativeScrollbarIfPossible: _propTypes.default.bool,
  inertialScroll: _propTypes.default.bool,
  rtl: _propTypes.default.bool,
  inlineBlock: _propTypes.default.bool,
  rafOnResize: _propTypes.default.bool,
  contain: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),
  onContainerScroll: _propTypes.default.func,
  onContainerScrollHorizontal: _propTypes.default.func,
  onContainerScrollHorizontalMax: _propTypes.default.func,
  onContainerScrollHorizontalMin: _propTypes.default.func,
  onContainerScrollVertical: _propTypes.default.func,
  onContainerScrollVerticalMax: _propTypes.default.func,
  onContainerScrollVerticalMin: _propTypes.default.func,
  onResize: _propTypes.default.func,
  onScroll: _propTypes.default.func,
  onScrollbarsChange: _propTypes.default.func,
  onScrollStart: _propTypes.default.func,
  onScrollStop: _propTypes.default.func,
  onViewResize: _propTypes.default.func,
  rafOnScroll: _propTypes.default.bool,
  scrollDebounceDelay: _propTypes.default.number,
  renderScroller: _propTypes.default.func,
  renderView: _propTypes.default.func,
  resizer: _propTypes.default.bool,
  scrollbars: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.shape({
    vertical: _propTypes.default.bool,
    horizontal: _propTypes.default.bool
  })]),
  usePassiveScroll: _propTypes.default.bool,
  showScrollbarsOnOver: _propTypes.default.bool,
  onScrollbarStartDrag: _propTypes.default.func,
  onScrollbarStopDrag: _propTypes.default.func,
  onHorizontalScrollbarStartDrag: _propTypes.default.func,
  onHorizontalScrollbarStopDrag: _propTypes.default.func,
  onVerticalScrollbarStartDrag: _propTypes.default.func,
  onVerticalScrollbarStopDrag: _propTypes.default.func,
  scrollerStyle: _propTypes.default.shape({}),
  scrollStopDelay: _propTypes.default.number,
  scrollThumbMargin: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  scrollMaxDelta: _propTypes.default.number,
  scrollThumbMinSize: _propTypes.default.number,
  scrollThumbOverWidth: _propTypes.default.number,
  scrollThumbRadius: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  scrollThumbStartEndRespectMargin: _propTypes.default.bool,
  scrollThumbWidth: _propTypes.default.number,
  scrollThumbStyle: _propTypes.default.shape(),
  scrollTrackOverTransitionDuration: _propTypes.default.string,
  showDelay: _propTypes.default.number,
  showTrackOnDrag: _propTypes.default.bool,
  shouldComponentUpdate: _propTypes.default.func,
  shouldAllowScrollbars: _propTypes.default.func,
  showTransitionDuration: _propTypes.default.string,
  tagName: _propTypes.default.string,
  theme: _propTypes.default.string,
  scrollerResizerProps: _propTypes.default.object,
  onDidMount: _propTypes.default.func,
  onWillUnmount: _propTypes.default.func,
  viewClassName: _propTypes.default.string,
  viewStyle: _propTypes.default.shape({}),
  wrapperStyle: _propTypes.default.shape({}),
  ResizeObserver: _propTypes.default.func,
  scrollThreshold: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  showScrollbars: _propTypes.default.bool
};
exports.propTypes = propTypes;
InovuaScrollContainer.propTypes = propTypes;