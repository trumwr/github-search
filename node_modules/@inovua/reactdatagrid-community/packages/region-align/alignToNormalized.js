/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _region = _interopRequireDefault(require("../region"));
function ALIGN_TO_NORMALIZED(sourceRegion, targetRegion, positions, config) {
  targetRegion = _region.default.from(targetRegion);
  config = config || {};
  var constrainTo = config.constrain,
    syncOption = config.sync,
    offsets = config.offset || [],
    syncWidth = false,
    syncHeight = false,
    sourceClone = sourceRegion.clone();
  if (!Array.isArray(positions)) {
    positions = positions ? [positions] : [];
  }
  if (!Array.isArray(offsets)) {
    offsets = offsets ? [offsets] : [];
  }
  if (constrainTo) {
    constrainTo = constrainTo === true ? _region.default.getDocRegion() : constrainTo.getRegion();
  }
  if (syncOption) {
    if (syncOption.size) {
      syncWidth = true;
      syncHeight = true;
    } else {
      syncWidth = syncOption === true ? true : syncOption.width || false;
      syncHeight = syncOption === true ? true : syncOption.height || false;
    }
  }
  if (syncWidth) {
    sourceClone.setWidth(targetRegion.getWidth());
  }
  if (syncHeight) {
    sourceClone.setHeight(targetRegion.getHeight());
  }
  var offset,
    i = 0,
    len = positions.length,
    pos,
    intersection,
    itArea,
    maxArea = -1,
    maxAreaIndex = -1;
  for (; i < len; i++) {
    pos = positions[i];
    offset = offsets[i];
    sourceClone.alignToRegion(targetRegion, pos);
    if (offset) {
      if (!Array.isArray(offset)) {
        offset = offsets[i] = [offset.x || offset.left, offset.y || offset.top];
      }
      sourceClone.shift({
        left: offset[0],
        top: offset[1]
      });
    }
    if (constrainTo) {
      intersection = sourceClone.getIntersection(constrainTo);
      if (intersection && intersection.equals(sourceClone)) {
        sourceRegion.set(sourceClone);
        return pos;
      } else {
        if (intersection && (itArea = intersection.getArea()) > maxArea) {
          maxArea = itArea;
          maxAreaIndex = i;
        }
      }
    } else {
      sourceRegion.set(sourceClone);
      return pos;
    }
  }
  if (~maxAreaIndex) {
    pos = positions[maxAreaIndex];
    offset = offsets[maxAreaIndex];
    sourceClone.alignToRegion(targetRegion, pos);
    if (offset) {
      sourceClone.shift({
        left: offset[0],
        top: offset[1]
      });
    }
    intersection = sourceClone.getIntersection(constrainTo);
    sourceClone.setRegion(intersection);
    sourceClone.alignToRegion(targetRegion, pos);
    if (offset) {
      sourceClone.shift({
        left: offset[0],
        top: offset[1]
      });
    }
    sourceRegion.set(sourceClone);
    return pos;
  }
}
var _default = ALIGN_TO_NORMALIZED;
exports.default = _default;